<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>微服务下使用GraphQL构建BFF | Blank</title><meta name="author" content="Blank"><meta name="copyright" content="Blank"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="微服务下使用GraphQL构建BFF 原文：https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;35108457 官网：https:&#x2F;&#x2F;graphql.cn&#x2F; 服务端库:https:&#x2F;&#x2F;graphql.cn&#x2F;code&#x2F;  微服务架构，这个在几年前还算比较前卫的技术在如今遍地开花。得益于开源社区的支持，我们可以轻松地利用 Spring Cloud 以及 Docker 容器化快速搭建一个微服务">
<meta property="og:type" content="article">
<meta property="og:title" content="微服务下使用GraphQL构建BFF">
<meta property="og:url" content="https://wangyyovo.github.io/posts/12f3861c/">
<meta property="og:site_name" content="Blank">
<meta property="og:description" content="微服务下使用GraphQL构建BFF 原文：https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;35108457 官网：https:&#x2F;&#x2F;graphql.cn&#x2F; 服务端库:https:&#x2F;&#x2F;graphql.cn&#x2F;code&#x2F;  微服务架构，这个在几年前还算比较前卫的技术在如今遍地开花。得益于开源社区的支持，我们可以轻松地利用 Spring Cloud 以及 Docker 容器化快速搭建一个微服务">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/microservice/dc2b938ad73884759e1fba950951d998.jpg">
<meta property="article:published_time" content="2020-10-21T02:00:36.000Z">
<meta property="article:modified_time" content="2020-10-21T02:00:36.000Z">
<meta property="article:author" content="Blank">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/microservice/dc2b938ad73884759e1fba950951d998.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "微服务下使用GraphQL构建BFF",
  "url": "https://wangyyovo.github.io/posts/12f3861c/",
  "image": "https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/microservice/dc2b938ad73884759e1fba950951d998.jpg",
  "datePublished": "2020-10-21T02:00:36.000Z",
  "dateModified": "2020-10-21T02:00:36.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Blank",
      "url": "https://wangyyovo.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/favicon.ico"><link rel="canonical" href="https://wangyyovo.github.io/posts/12f3861c/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Blank","link":"链接: ","source":"来源: Blank","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '微服务下使用GraphQL构建BFF',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="alternate" href="/atom.xml" title="Blank" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">352</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 教程</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/21cfbf15/"><span> 🚀 快速開始</span></a></li><li><a class="site-page child" href="/posts/dc584b87/"><span> 📑 主題頁面</span></a></li><li><a class="site-page child" href="/posts/4aa8abbe/"><span> 🛠 主題配置</span></a></li><li><a class="site-page child" href="/posts/ceeb73f/"><span> ⚔️ 標簽外挂</span></a></li><li><a class="site-page child" href="/posts/98d20436/"><span> ❓ 主題問答</span></a></li><li><a class="site-page child" href="/posts/4073eda/"><span> ⚡️ 進階教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/microservice/dc2b938ad73884759e1fba950951d998.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Blank</span></a><a class="nav-page-title" href="/"><span class="site-name">微服务下使用GraphQL构建BFF</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 教程</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/21cfbf15/"><span> 🚀 快速開始</span></a></li><li><a class="site-page child" href="/posts/dc584b87/"><span> 📑 主題頁面</span></a></li><li><a class="site-page child" href="/posts/4aa8abbe/"><span> 🛠 主題配置</span></a></li><li><a class="site-page child" href="/posts/ceeb73f/"><span> ⚔️ 標簽外挂</span></a></li><li><a class="site-page child" href="/posts/98d20436/"><span> ❓ 主題問答</span></a></li><li><a class="site-page child" href="/posts/4073eda/"><span> ⚡️ 進階教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">微服务下使用GraphQL构建BFF</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-21T02:00:36.000Z" title="发表于 2020-10-21 10:00:36">2020-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-21T02:00:36.000Z" title="更新于 2020-10-21 10:00:36">2020-10-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/microservice/">microservice</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><script src="\assets\js\APlayer.min.js"> </script><h1 id="微服务下使用GraphQL构建BFF"><a href="#微服务下使用GraphQL构建BFF" class="headerlink" title="微服务下使用GraphQL构建BFF"></a>微服务下使用GraphQL构建BFF</h1><blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35108457">https://zhuanlan.zhihu.com/p/35108457</a></p>
<p>官网：<a target="_blank" rel="noopener" href="https://graphql.cn/">https://graphql.cn/</a></p>
<p>服务端库:<a target="_blank" rel="noopener" href="https://graphql.cn/code/">https://graphql.cn/code/</a></p>
</blockquote>
<p>微服务架构，这个在几年前还算比较前卫的技术在如今遍地开花。得益于开源社区的支持，我们可以轻松地利用 Spring Cloud 以及 Docker 容器化快速搭建一个微服务架构的原型。不管是成熟的互联网公司、创业公司还是个人开发者，对于微服务架构的接纳程度都相当高，微服务架构的广泛应用也自然促进了技术本身更好的发展以及更多的实践。本文将结合项目实践，剖析在微服务的背景下，如何通过前后端分离的方式开发移动应用。</p>
<p>对于微服务本身，我们可以参考 Martin Fowler 对 <a href="https://link.zhihu.com/?target=https://martinfowler.com/articles/microservices.html">Microservice</a> 的阐述。简单说来，微服务是一种架构风格。通过对特定业务领域的分析与建模，将复杂的应用分解成小而专一、耦合度低并且高度自治的一组服务。微服务中的每个服务都是很小的应用，这些应用服务相互独立并且可部署。微服务通过对复杂应用的拆分，达到简化应用的目的，而这些耦合度较低的服务则通过 API 形式进行通信，所以服务之间对外暴露的都是 API，不管是对资源的获取还是修改。</p>
<p>微服务架构的这种理念，和前后端分离的理念不谋而合，前端应用控制自己所有的 UI 层面的逻辑，而数据层面则通过对微服务系统的 API 调用完成。以 JSP (Java Server Pages) 为代表的前后端交互方式也逐渐退出历史舞台。前后端分离的迅速发展也得益于前端 Web 框架 (Angular, React 等) 的不断涌现，单页面应用(Single Page Application)迅速成为了一种前端开发标准范式。加之移动互联网的发展，不管是 Mobile Native 开发方式，还是 React Native &#x2F; PhoneGap 之流代表的 Hybrid 应用开发方式，前后端分离让 Web 和移动应用成为了**客户端。**客户端只需要通过 API 进行资源的查询以及修改即可。</p>
<h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p>一种用于 API 的查询语言</p>
<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p>
<h2 id="GraphQL优缺点"><a href="#GraphQL优缺点" class="headerlink" title="GraphQL优缺点"></a>GraphQL优缺点</h2><h3 id="GraphQL-的优点"><a href="#GraphQL-的优点" class="headerlink" title="GraphQL 的优点"></a>GraphQL 的优点</h3><p>接下来会列举在应用中使用 GraphQL 的主要优点。</p>
<h4 id="声明式地数据获取"><a href="#声明式地数据获取" class="headerlink" title="声明式地数据获取"></a>声明式地数据获取</h4><p>如之前看到的那样，GraphQL 在使用查询语句式，使用声明式的方式获取数据。客户端在一个查询请求中，选择需要的数据和相关的字段实体。客户端根据其 UI 来决定需要的字段。你可以说这是 UI 驱动地数据获取。比方说，Airbnb 使用 GraphQL的例子，在 Airbnb 中的一个搜索界面，经常需要搜索房屋的住房体验和其他相关的一些信息，为了能在一个请求中检索所有的数据，一个 GraphQL 查询会根据 UI 选择数据中的一部分达到完美的匹配。毕竟，GraphQL 提供了极佳的关注点分离方式：客户端知道它需要什么数据，服务端知道数据的结构，以及如何从一些数据源（比如数据库、微服务、第三方 API）中拉取数据。</p>
<h4 id="在-GraphQL-中没有过度获取"><a href="#在-GraphQL-中没有过度获取" class="headerlink" title="在 GraphQL 中没有过度获取"></a>在 GraphQL 中没有过度获取</h4><p>使用 GraphQL 不会存在过度获取的现象。使用与 Web 客户端公用的一个 RESTful API，一个移动客户端很可能会获取过多的数据，但是使用同样的 GraphQL API，移动客户端可以选择和 Web 客户端不同的数据字段。因此移动客户端能减少获取的信息，因为相对于 Web 应用的更大的屏幕，小屏幕上可能显示不了那么多信息。GraphQL 通过最开始按客户端需求选择数据，减少了传输数据的大小。</p>
<h4 id="在-React、Angular、Node-和-Co-中的-GraphQL"><a href="#在-React、Angular、Node-和-Co-中的-GraphQL" class="headerlink" title="在 React、Angular、Node 和 Co 中的 GraphQL"></a>在 React、Angular、Node 和 Co 中的 GraphQL</h4><p>GraphQL 并不只让 React 的开发者激动。即便 Facebook 只展示了一个使用 React 的客户端程序，但是它和任何前端或者后端的解决方案是解耦的，无关的。GraphQL 的相关实现是用 JavaScript 写的，因此 GraphQL 可以用在 Angular、Vue、Express、Hapi、Koa 以及任何其他客户端或者服务端的 JavaScript 类库上，并且这还只是在 JavaScript 的生态中。GraphQL 模仿了让 REST 这么流行的一个特点：一个两个实体（比如服务端和客户端）语言无关的接口（查询语言）。这样你可以在任意编程语言中通过使用一个 GraphQL 标准的实现使用 GraphQL 了。</p>
<h4 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h4><p>在 GraphQL 应用中存在者单一数据源：GraphQL schema。它提供了一个所有可用数据检索的源头。鉴于 GraphQL 的 schema 通常会在服务端定义，客户端可以基于 schema 读取（query）和写入（mutation）数据。因此，服务端提供了所有可用的信息，客户端只需要执行 GraphQL 查询获取部分数据，或者通过 GraphQL 修改变更部分数据。</p>
<h4 id="拼接-GraphQL-Schema"><a href="#拼接-GraphQL-Schema" class="headerlink" title="拼接 GraphQL Schema"></a>拼接 GraphQL Schema</h4><p>拼接 Schema 使得多个 schema 可以聚合成一个。什么时候你需要考虑这个？考虑一下后端的微服务架构。每个微服务处理特定域的业务逻辑和数据。因此，每个微服务都可以定义自己的GraphQL架构。之后，使用 Schema 拼接将所有 Schema 聚合到一个可以被客户端访问的 Schema 中。最终，每个微服务都可以拥有自己的 GraphQL 端点，而一个 GraphQL API网关将所有 schema 合并到一个全局 schema 中，以便使得客户端可以使用。</p>
<h4 id="GraphQL-自省"><a href="#GraphQL-自省" class="headerlink" title="GraphQL 自省"></a>GraphQL 自省</h4><p>GraphQL 自省允许通过 GraphQL API 检索 GraphQL schema。因为 schema 包含了 GraphQL API 可以获得的所有数据信息，本身就是一份完美的自动生成的 API 文档。不仅仅是 API 的文档，也允许客户端通过mock GraphQL 的 schema 达到测试的目的，或者使用 schema 拼接的接口检索多个微服务的 schema。</p>
<h4 id="强类型的-GraphQL"><a href="#强类型的-GraphQL" class="headerlink" title="强类型的 GraphQL"></a>强类型的 GraphQL</h4><p>GraphQL 是一门强类型的查询语言，因为它是通过 GraphQL Schema Definition Language（SDL）书写的。因为有了强类型，它就拥有了强类型编程语言一样的好处：更不容出错、可以在编辑期验证并且支持编辑器智能补全和验证相关的集成。</p>
<h4 id="GraphQL-版本化"><a href="#GraphQL-版本化" class="headerlink" title="GraphQL 版本化"></a>GraphQL 版本化</h4><p>在 GraphQL 中没有 API 版本的说法。在 REST 中，通常会提供一个 API 的多个版本（比如 api.domain.com&#x2F;v1&#x2F;、api.domain.com&#x2F;v2&#x2F;），因为随着时间过去，可能资源的结构也会发生变化。在 GraphQL 中，API 废弃可以做到字段级别，因此当一个客户端减少到一个废弃的字段，会得到一个废弃相关的警告。当没有客户端再使用这个废弃知道后，就可以从 schema 汇总移除这个字段了。这让一个 GraphQL API 不需要使用版本化的方式来演进。</p>
<h4 id="成长中的-GraphQL-生态"><a href="#成长中的-GraphQL-生态" class="headerlink" title="成长中的 GraphQL 生态"></a>成长中的 GraphQL 生态</h4><p>GraphQL 的生态正在发展壮大。不仅仅是 GraphQL 天然的强类型特性适宜集成编辑器和 IDE 的演进，GraphQL 相关的应用也在演进。你可能记得在处理 REST API 的时候的 <a target="_blank" rel="noopener" href="https://www.getpostman.com/">Postman</a>，现在有 <a target="_blank" rel="noopener" href="https://github.com/graphql/graphiql">GraphiQL</a> 或者 <a target="_blank" rel="noopener" href="https://github.com/prismagraphql/graphql-playground">GraphQL Playground</a>可以调试你的应用。你也可以找到如 <a target="_blank" rel="noopener" href="https://www.gatsbyjs.org/">Gatsby.js</a> 这样的使用 GraphQL 的 React 静态页面生成器。比如，使用 Gatsby.js 你可以在构建时期通过一个 GraphQL 来提供你的博客内容来源。你可能还听说过内容管理系统（CMS）（比如 <a target="_blank" rel="noopener" href="https://graphcms.com/">GraphCMS</a>）通过 GraphQL API 来提供（博客）内容。不仅在技术领域有所演进，这还有很多 GraphQL 相关 大会、聚会和社区不断涌现，并且也可以通过一些 newsletters 和 podcast 了解到 GraphQL。</p>
<h4 id="我应该全部投入到-GraphQL-么？"><a href="#我应该全部投入到-GraphQL-么？" class="headerlink" title="我应该全部投入到 GraphQL 么？"></a>我应该全部投入到 GraphQL 么？</h4><p>采用 GraphQL 并不需要将现有技术栈全部一步推翻。如果你计划从一个单体后端应用迁移到一个微服务架构上去，正是一个绝好的时机为新的微服务引入 GraphQL API。当有多个微服务时，你的团队可以通过 schema 拼接的方式引入一个 GraphQL 网关（gateway）。不过 API 网关并不是微服务中才能使用的方式，单体 REST 应用也可以。你可以通过将所有现有的 API  通过一个 API 网关不断一步一步汇集到一起，逐步完成到 GraphQL 的迁移。</p>
<h3 id="GraphQL-的缺点"><a href="#GraphQL-的缺点" class="headerlink" title="GraphQL 的缺点"></a>GraphQL 的缺点</h3><p>下面的话题展示了使用 GraphQL 的一些不足</p>
<h4 id="GraphQL-查询的复杂性"><a href="#GraphQL-查询的复杂性" class="headerlink" title="GraphQL 查询的复杂性"></a>GraphQL 查询的复杂性</h4><p>人们经常错误地认为 GraphQL 就是在后端替代了数据库。并不是这样的，GraphQL 仅仅是一个查询语言。在服务端，一个查询需要解析数据，因此一个 GraphQL 相关实现常常需要执行数据库访问，但 GraphQL 其实不关心这些。还有，GraphQL 在你需要在一个查询中获取多个字段（作者、文章、评论）的时候，它对性能瓶颈没有任何帮助。无论使用 RESTful 架构还是 GraphQL，不同资源&#x2F;字段仍然需要从一个数据源去获取。</p>
<p>因此当一个客户端需要一次查询很多嵌套字段时，前端开发通常不能很清楚他正在通过服务端访问不同的数据库获取过多的数据。这需要一种机制（比如最深查询深度、查询复杂度权重、避免递归、持久化查询）来制止来自客户端的（性能）昂贵的查询。</p>
<h4 id="查询频率限制"><a href="#查询频率限制" class="headerlink" title="查询频率限制"></a>查询频率限制</h4><p>另一个问题是频率限制，在 REST 中，可以简单的声明”一天之中，我们只允许请求这么多资源“，在一个独立的 GraphQL 操作中很难做到这一点，因为任何操作的开销都可以是廉价的或者昂贵的。这就是那些有着公共 GraphQL API 的公司提出的特定速率限制计算，通常可以归结为前面提到的最大查询深度和查询复杂度权重问题。</p>
<h4 id="GraphQL-缓存"><a href="#GraphQL-缓存" class="headerlink" title="GraphQL 缓存"></a>GraphQL 缓存</h4><p>一个简单缓存，相比 REST，在 GraphQL 中实现会变得极其复杂。在 REST 中你通过 URL 访问资源，因此你可以在资源级别实现缓存，因为资源使用 URL 作为其标识符。在 GraphQL 中就复杂了，因为即便它操作的是同一个实体，每个查询都各不相同。比如，一个查询中，你可能只会请求一个作者的名字，但是在另外一次查询中你可能也想知道他的电子邮箱地址。这就需要你有一个更加健全的机制中来确保字段级别的缓存，实现起来并不简单。不过，多数基于 GraphQL 构建的类库都提供了开箱即用的缓存机制。</p>
<h3 id="为什么不用-REST-呢？"><a href="#为什么不用-REST-呢？" class="headerlink" title="为什么不用 REST 呢？"></a>为什么不用 REST 呢？</h3><p>GraphQL 是通常用来连接客户端和服务端的 RESTful 架构的替代方案。在前面的内容中，你已经多次听到 REST 了，那么什么是使用 GraphQL 而不是 RESTful ，显而易见的好处呢？</p>
<p>因为 REST 提出通过 URL 来标识资源，最终常常会出现低效的连续请求。比方说，最开始你通过 id 来定位一个作者实体，然后你通过作者的 id 获取的某个信息来请求他所有的文章。在 GraphQL 中只需要一个请求就能办到，这是更加效率的。更进一步而言，如果你想只想获取作者的所有文章数据，而不关心作者的信息，GraphQL 允许只你选择你需要的信息。在 REST 中，你需要先获取作者的所有实体信息，即使你值关心被这个作者写的文章而已。因为过度获取这个问题，只有在使用 REST 才会出现，而 GraphQL 就不会。</p>
<p>现在客户端应用不适合 RESTful 的服务端应用了。比方说，在 Airbnb 平台上，获取搜索结果，它为你展示了房屋、住房体验以及其他相关信息。住房和住房体验在各自的 RESTful 资源中，那么你需要支持多个网络请求。当使用 GraphQL API，你只需要在一个 GraphQL 查询中一起获取所有需要的实体（比如住房和住房体验）或者嵌套的其他相关信息（比如作者的文章信息）。</p>
<p>最终 GraphQL 将数据有服务端主导返回什么数据变成了客户端决定需要什么什么。这就是一开始 GraphQL 被发明的原因，因为在 Facebook 的一个移动应用和他们的 web 应用需要的数据是不一样的。</p>
<p>总之，仍然有些场景下使用 REST 来沟通客户端和服务端是有价值的途径，通常应用是资源驱动，也不需要像 GraphQL 这些的查询语言提供的灵活能力。然而，我还是推荐你尝试使用 GraphQL 来开发你的下一个客户&#x2F;服务端架构。</p>
<h2 id="BFF-概况及演进"><a href="#BFF-概况及演进" class="headerlink" title="BFF 概况及演进"></a>BFF 概况及演进</h2><p>Backend for Frontends(以下简称BFF) 顾名思义，是为前端而存在的后端(服务)中间层。即传统的前后端分离应用中，前端应用直接调用后端服务，后端服务再根据相关的业务逻辑进行数据的增删查改等。那么引用了 BFF 之后，前端应用将直接和 BFF 通信，BFF 再和后端进行 API 通信，所以本质上来说，BFF 更像是一种“中间层”服务。下图看到没有BFF以及加入BFF的前后端项目上的主要区别。</p>
<h3 id="1-没有BFF-的前后端架构"><a href="#1-没有BFF-的前后端架构" class="headerlink" title="1. 没有BFF 的前后端架构"></a>1. 没有BFF 的前后端架构</h3><p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/microserive/bff1.jpg"></p>
<p>在传统的前后端设计中，通常是 App 或者 Web 端直接访问后端服务，后台微服务之间相互调用，然后返回最终的结果给前端消费。对于客户端（特别是移动端）来说，过多的 HTTP 请求是很昂贵的，所以开发过程中，为了尽量减少请求的次数，前端一般会倾向于把有关联的数据通过一个 API 获取。在微服务模式下，意味着<strong>有时为了迎合客户端的需求，服务器常会做一些与UI有关的逻辑处理</strong>。</p>
<h3 id="2-加入了BFF-的前后端架构"><a href="#2-加入了BFF-的前后端架构" class="headerlink" title="2. 加入了BFF 的前后端架构"></a>2. 加入了BFF 的前后端架构</h3><p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/microserive/bff2.jpg" alt="img"></p>
<p>加入了BFF的前后端架构中，最大的区别就是前端(Mobile, Web) 不再直接访问后端微服务，而是通过 BFF 层进行访问。并且<strong>每种客户端都会有一个BFF服务</strong>。从微服务的角度来看，有了 BFF 之后，微服务之间的相互调用更少了。这是因为一些UI的逻辑在 BFF 层进行了处理。</p>
<h2 id="BFF-和-API-Gateway"><a href="#BFF-和-API-Gateway" class="headerlink" title="BFF 和 API Gateway"></a>BFF 和 API Gateway</h2><p>从上文对 BFF 的了解来看，BFF 既然是前后端访问的中间层服务，那么 BFF 和 API Gateway 有什么区别呢？我们首先来看下 API Gateway 常见的实现方式。（API Gateway 的设计方式可能很多，这里只列举如下三种）</p>
<h2 id="1-API-Gateway-的第一种实现：一个-API-Gateway-对所有客户端提供同一种-API"><a href="#1-API-Gateway-的第一种实现：一个-API-Gateway-对所有客户端提供同一种-API" class="headerlink" title="1. API Gateway 的第一种实现：一个 API Gateway 对所有客户端提供同一种 API"></a>1. API Gateway 的第一种实现：一个 API Gateway 对所有客户端提供同一种 API</h2><p><strong>单个</strong> API Gateway 实例，为<strong>多种</strong>客户端提供<strong>同一种API</strong>服务，这种情况下，API Gateway 不对客户端类型做区分。即所有 <code>/api/users</code>的处理都是一致的，API Gateway 不做任何的区分。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/microserive/bff3.jpg" alt="img"></p>
<h2 id="2-API-Gateway-的第二种实现：一个-API-Gateway-对每种客户端提供分别的-API"><a href="#2-API-Gateway-的第二种实现：一个-API-Gateway-对每种客户端提供分别的-API" class="headerlink" title="2. API Gateway 的第二种实现：一个 API Gateway 对每种客户端提供分别的 API"></a>2. API Gateway 的第二种实现：一个 API Gateway 对每种客户端提供分别的 API</h2><p><strong>单个</strong> API Gateway 实例，为<strong>多种</strong>客户端提供<strong>各自不同的API</strong>。比如对于 users 列表资源的访问，web 端和 App 端分别通过 <code>/services/mobile/api/users</code>, <code>/services/web/api/users</code>服务。API Gateway 根据不同的 API 判定来自于哪个<strong>客户端</strong>，然后分别进行处理，返回不同客户端所需的资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/microserive/bff4.jpg" alt="img"></p>
<h2 id="3-API-Gateway-的第三种实现：多个-API-Gateway-分别对每种客户端提供分别的-API"><a href="#3-API-Gateway-的第三种实现：多个-API-Gateway-分别对每种客户端提供分别的-API" class="headerlink" title="3. API Gateway 的第三种实现：多个 API Gateway 分别对每种客户端提供分别的 API"></a>3. API Gateway 的第三种实现：多个 API Gateway 分别对每种客户端提供分别的 API</h2><p>在这种实现下，针对<strong>每种类型的客户端</strong>，都会有一个<strong>单独的 API Gateway</strong> 响应其 API 请求。所以说 BFF 其实是 API Gateway 的其中一种实现模式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/microserive/bff5.jpg" alt="img"></p>
<h2 id="GraphQL-与-REST"><a href="#GraphQL-与-REST" class="headerlink" title="GraphQL 与 REST"></a>GraphQL 与 REST</h2><blockquote>
<p><em>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</em></p>
</blockquote>
<p>GraphQL 作为一种 API 查询语句，于2015年被 Facebook 推出，主要是为了替代传统的 REST 模式，那么对于 GraphQL 和 REST 究竟有哪些异同点呢？我们可以通过下面的例子进行理解。</p>
<p>按照 REST 的设计标准来看，所有的访问都是基于对资源的访问（增删查改）。如果对系统中 <code>users</code> 资源的访问，REST 可能通过下面的方式访问：</p>
<p><strong>Request:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://localhost/api/users</span><br></pre></td></tr></table></figure>

<p><strong>Response:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;name&quot;: &quot;abc&quot;,</span><br><span class="line">    &quot;avatar&quot;: &quot;http://cdn.image.com/image_avatar1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>对于同样的请求如果用 GraphQL 来访问，过程如下：</li>
</ul>
<p><strong>Request:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST http://localhost/graphql</span><br></pre></td></tr></table></figure>

<p><strong>Body:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query &#123;users &#123; id, name, avatar &#125; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Response:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;users&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 1,</span><br><span class="line">        &quot;name&quot;: &quot;abc&quot;,</span><br><span class="line">        &quot;avatar&quot;: &quot;http://cdn.image.com/image_avatar1&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 GraphQL 更详细的用法，我们可以通过查看文档以及其他文章更加详细的去了解。相比于 REST 风格，GraphQL 具有如下特性：</p>
<h3 id="1-定义数据模型：按需获取"><a href="#1-定义数据模型：按需获取" class="headerlink" title="1. 定义数据模型：按需获取"></a>1. 定义数据模型：按需获取</h3><p>GraphQL 在服务器实现端，需要定义不同的数据模型。前端的所有访问，最终都是通过 GraphQL 后端定义的数据模型来进行映射和解析。并且这种基于模型的定义，能够做到按需索取。比如对上文 <code>/users</code> 资源的获取，如果客户端只关心 <code>user.id</code>, <code>user.name</code> 信息。那么在客户端调用的时候，<code>query</code> 中只需要传入 <code>users &#123;id \n name&#125;</code>即可。后台定义模型，客户端只需要获取自己关心的数据即可。</p>
<h3 id="2-数据分层"><a href="#2-数据分层" class="headerlink" title="2. 数据分层"></a>2. 数据分层</h3><p>查询一组<code>users</code>数据，可能需要获取 <code>user.friends, user.friends.addr</code> 等信息，所以针对 users 的本次查询，实际上分别涉及到对 <code>user</code>, <code>frind</code>, <code>addr</code>三类数据。GraphQL 对分层数据的查询，大大减少了客户端请求次数。因为在 REST 模式下，可能意味着每次获取 <code>user</code> 数据之后，需要再次发送 API 去请求 friends 接口。而 GraphQL 通过数据分层，能够让客户端通过一个 API获取所有需要的数据。这也就是 GraphQL（图查询语句 Graph Query Language）名称的由来。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  user(<span class="name">id:1001</span>) &#123; // 第一层</span><br><span class="line">    name,</span><br><span class="line">    friends &#123; // 第二层</span><br><span class="line">      name,</span><br><span class="line">      addr &#123; // 第三层</span><br><span class="line">        country,</span><br><span class="line">        city</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-强类型"><a href="#3-强类型" class="headerlink" title="3. 强类型"></a>3. 强类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Meeting</span> = <span class="keyword">new</span> <span class="title class_">GraphQLObjectType</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Meeting&#x27;</span>,</span><br><span class="line">  <span class="attr">fields</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">meetingId</span>: &#123;<span class="attr">type</span>: <span class="keyword">new</span> <span class="title class_">GraphQLNonNull</span>(<span class="title class_">GraphQLString</span>)&#125;,</span><br><span class="line">    <span class="attr">meetingStatus</span>: &#123;<span class="attr">type</span>: <span class="keyword">new</span> <span class="title class_">GraphQLNonNull</span>(<span class="title class_">GraphQLString</span>), <span class="attr">defaultValue</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>GraphQL 的类型系统定义了包括 Int, Float, String, Boolean, ID, Object, List, Non-Null 等数据类型。所以在开发过程中，利用强大的强类型检查，能够大大节省开发的时间，同时也很方便前后端进行调试。</p>
<h3 id="4-协议而非存储"><a href="#4-协议而非存储" class="headerlink" title="4. 协议而非存储"></a>4. 协议而非存储</h3><p>GraphQL 本身并不直接提供后端存储的能力，它不绑定任何的数据库或者存储引擎。它利用已有的代码和技术进行数据源的管理。比如作为在 BFF 层使用 GraphQL, 这一层的 BFF 并不需要任何的数据库或者存储媒介。GraphQL 只是解析客户端请求，知道客户端的“意图”之后，再通过对微服务API的访问获取到数据，对数据进行一系列的组装或者过滤。</p>
<h3 id="5-无须版本化"><a href="#5-无须版本化" class="headerlink" title="5. 无须版本化"></a>5. 无须版本化</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const PhotoType = new GraphQLObjectType(&#123;</span><br><span class="line">  name: &#x27;Photo&#x27;,</span><br><span class="line">  fields: () =&gt; (&#123;</span><br><span class="line">    photoId: &#123;type: new GraphQLNonNull(GraphQLID)&#125;,</span><br><span class="line">    file: &#123;</span><br><span class="line">      type: new GraphQLNonNull(FileType),</span><br><span class="line">      deprecationReason: &#x27;FileModel should be removed after offline app code merged.&#x27;,</span><br><span class="line">      resolve: (parent) =&gt; &#123;</span><br><span class="line">        return parent.file</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fileId: &#123;type: new GraphQLNonNull(GraphQLID)&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>GraphQL 服务端能够通过添加 deprecationReason，自动将某个字段标注为弃用状态。并且基于 GraphQL 高度的可扩展性，如果不需要某个数据，那么只需要使用新的字段或者结构即可，老的弃用字段给老的客户端提供服务，所有新的客户端使用新的字段获取相关信息。并且考虑到所有的 graphql 请求，都是按照 POST <code>/graphql</code> 发送请求，所以在 GraphQL 中是无须进行版本化的。</p>
<h3 id="GraphQL-和-REST"><a href="#GraphQL-和-REST" class="headerlink" title="GraphQL 和 REST"></a>GraphQL 和 REST</h3><p>对于 GraphQL 和 REST 之间的对比，主要有如下不同：</p>
<p>**1. 数据获取：**REST 缺乏可扩展性， GraphQL 能够按需获取。GraphQL API 调用时，payload 是可以扩展的;</p>
<p>**2. API 调用：**REST 针对每种资源的操作都是一个 endpoint, GraphQL 只需要一个 endpoint( &#x2F;graphql), 只是 post body 不一样;</p>
<p>**3. 复杂数据请求：**REST 对于嵌套的复杂数据需要多次调用，GraphQL 一次调用, 减少网络开销；</p>
<p>**4. 错误码处理：**REST 能够精确返回HTTP错误码，GraphQL 统一返回200，对错误信息进行包装；</p>
<p>**5. 版本号：**REST通过 v1&#x2F;v2 实现，GraphQL 通过 Schema 扩展实现；</p>
<h2 id="微服务-GraphQL-BFF-实践"><a href="#微服务-GraphQL-BFF-实践" class="headerlink" title="微服务 + GraphQL + BFF 实践"></a>微服务 + GraphQL + BFF 实践</h2><p>在微服务下基于 GraphQL 构建 BFF，我们在项目中已经开始了相关的实践。在我们项目对应的业务场景下，微服务后台有近 10 个微服务，客户端包括针对不同角色的4个 App 以及一个 Web 端。对于每种类型的 App，都有一个 BFF 与之对应。每种 BFF 只服务于这个 App。BFF 解析到客户端请求之后，会通过 BFF 端的服务发现，去对应的微服务后台通过 CQRS 的方式进行数据查询或修改。</p>
<h3 id="1-BFF-端技术栈"><a href="#1-BFF-端技术栈" class="headerlink" title="1. BFF 端技术栈"></a>1. BFF 端技术栈</h3><p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/microserive/bff6.jpg" alt="img"></p>
<p>我们使用 GraphQL-express 框架构建项目的 BFF 端，然后通过 Docker 进行部署。BFF 和微服务后台之间，还是通过 registrator 和 Consul 进行服务注册和发现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addRoutes () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">express</span>.<span class="title function_">use</span>(<span class="string">&#x27;/graphql&#x27;</span>, <span class="variable language_">this</span>.<span class="title function_">resolveFromRequestScopeAndHandle</span>(<span class="string">&#x27;GraphqlHandler&#x27;</span>))</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">serviceNames</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">serviceName</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">express</span>.<span class="title function_">use</span>(<span class="string">`/api/<span class="subst">$&#123;serviceName&#125;</span>`</span>, <span class="variable language_">this</span>.<span class="property">routers</span>.<span class="property">apiProxy</span>.<span class="title function_">createRouter</span>(serviceName))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 BFF 的路由设置中，对于客户端的处理，主要有 <code>/graphql</code> 和 <code>/api/$&#123;serviceName&#125;</code>两部分。<code>/graphql</code> 处理的是所有 GraphQL 查询请求，同时我们在 BFF 端增加了 <code>/api/$&#123;serviceName&#125;</code> 进行 API 透传，对于一些没有必要进行 GraphQL 封装的请求，可以直接通过透传访问到相关的微服务中。</p>
<h3 id="2-整体技术架构"><a href="#2-整体技术架构" class="headerlink" title="2. 整体技术架构"></a>2. 整体技术架构</h3><p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/microserive/bff7.jpg" alt="img"></p>
<p>整体来看，我们的前后端架构图如下，三个 App 客户端分别使用 GraphQL 的形式请求对应的 BFF。BFF 层再通过 Consul 服务发现和后端通信。</p>
<h3 id="关于系统中的鉴权问题"><a href="#关于系统中的鉴权问题" class="headerlink" title="关于系统中的鉴权问题"></a>关于系统中的鉴权问题</h3><p>用户登录后，App 直接访问 KeyCloak 服务获取到 <code>id_token</code>，然后通过 <code>id_token</code> 透传访问 <code>auth-api</code> 服务获取到 <code>access_token</code>, access_token 以 JWT (Json Web Token) 的形式放置到后续 http 请求的头信息中。</p>
<p>在我们这个系统中 BFF 层并不做鉴权服务，所有的鉴权过程全部由各自的微服务模块负责。BFF 只提供中转的功能。BFF 是否需要集成鉴权认证，主要看各系统自己的设计，并不是一个标准的实践。</p>
<h3 id="3-GraphQL-BFF-实践"><a href="#3-GraphQL-BFF-实践" class="headerlink" title="3. GraphQL + BFF 实践"></a>3. GraphQL + BFF 实践</h3><p>通过如下几个方面，可以思考基于 GraphQL 的 BFF 的一些更好的特质：</p>
<h4 id="GraphQL-和-BFF-对业务点的关注"><a href="#GraphQL-和-BFF-对业务点的关注" class="headerlink" title="GraphQL 和 BFF 对业务点的关注"></a>GraphQL 和 BFF 对业务点的关注</h4><p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/microserive/bff8.jpg" alt="img"></p>
<p>从业务上来看，PM App（使用者：物业经理）关注的是<code>property</code>，物业经理管理着一批房屋，所以需要知道所有房屋概况，对于每个房屋需要知道有没有对应的维修申请。所以 PM App BFF 在定义数据结构是，<code>maintemamceRequests</code> 是 <code>property</code> 的子属性。</p>
<p>同样类似的数据，Supplier App（使用者：房屋维修供应商）关注的是 maintenanceRequest（维修工单），所以在 Supplier App 获取的数据里，我们的主体是<code>maintenanceRequest</code>。维修供应商关注的是 <code>workOrder.maintenanceRequest</code>。</p>
<p>所以不同的客户端，因为存在着不同的使用场景，所以对于同样的数据却有着不同的关注点。<code>BFF is pary of Application</code>。从这个角度来看，BFF 中定义的数据结构，就是客户端所真正关心的。BFF 就是为客户端而生，是客户端的一部分。需要说明的是，对于“业务的关注”并不是说，BFF会处理所有的业务逻辑，业务逻辑还是应该由微服务关心，BFF 关注的是客户端需要什么。</p>
<h4 id="GraphQL-对版本化的支持"><a href="#GraphQL-对版本化的支持" class="headerlink" title="GraphQL 对版本化的支持"></a>GraphQL 对版本化的支持</h4><p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/microserive/bff9.jpg" alt="img"></p>
<p>假设 BFF 端已经发布到生产环境，提供了 <code>inspection</code> 相关的 <code>tenants</code> 和 <code>landlords</code> 的查询。现在需要将图一的结构变更为图二的结构，但是为了不影响老用户的 API 访问，这时候我们的 BFF API 必须进行兼容。如果在 REST 中，可能会增加 <code>api/v2/inspections</code>进行 API 升级。但是在 BFF 中，为了向前兼容，我们可以使用图三的结构。这时候老的 APP 使用黄色区域的数据结构，而新的 APP 则使用蓝色区域定义的结构。</p>
<h4 id="GraphQL-Mutation-与-CQRS"><a href="#GraphQL-Mutation-与-CQRS" class="headerlink" title="GraphQL Mutation 与 CQRS"></a>GraphQL Mutation 与 CQRS</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  area &#123;</span><br><span class="line">    create (input: &#123;</span><br><span class="line">      areaId:&quot;111&quot;, </span><br><span class="line">      name:&quot;test&quot;, </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你详细阅读了 GraphQL 的文档，可以发现 GraphQL 对 <code>query</code> 和 <code>mutation</code> 进行了分离。所有的查询应该使用 <code>query &#123; ...&#125;</code>，相应的 mutaition 需要使用 <code>mutation &#123; ... &#125;</code>。虽然看起来像是一个convention，但是 GraphQL 的这种设计和后端 API 的 读写职责分离（Command Query Responsibility Segregation）不谋而合。而实际上我们使用的时候也遵从这个规范。所以的 mutation 都会调用后台的 API，而后端的 API 对于资源的修改也是通过 SpringBoot EventListener 实现的 CQRS 模式。</p>
<h4 id="如何做好测试"><a href="#如何做好测试" class="headerlink" title="如何做好测试"></a>如何做好测试</h4><p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/microserive/bff10.jpg" alt="img"></p>
<p>在引入了 BFF 的项目，我们的测试仍然使用金字塔原理，只是在客户端和后台之间，需要添加对 BFF 的测试。</p>
<ul>
<li>Client 的 integration-test 关心的是 App 访问 BFF 的连通性，App 中所有访问 BFF 的请求都需要进行测试；</li>
<li>BFF 的 integration-test 测试的是 BFF 到微服务 API 的连通性，BFF 中依赖的所有 API 都应该有集成测试的保障；</li>
<li>API 的 integration-test 关注的是这个服务对外暴露的所有 API，通常测试所有的 Controller 中的 API；</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>微服务下基于 GraphQL 构建 BFF 并不是银弹，也并不一定适合所有的项目，比如当你使用 GraphQL 之后，你可能得面临多次查询性能问题等，但这不妨碍它成为一个不错的尝试。你也的确看到 Facebook 早已经使用 GraphQL，而且 Github 也开放了 GraphQL 的API。而 BFF， 其实很多团队也都已经在实践了，在微服务下等特殊场景下，GraphQL + BFF 也许可以给你的项目带来惊喜。</p>
<p><strong>参考资料</strong></p>
<p>【注】部分图片来自网络</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.thoughtworks.com/insights/blog/bff-soundcloud">https://www.thoughtworks.com/insights/blog/bff-soundcloud</a></li>
<li><a href="https://link.zhihu.com/?target=http://philcalcado.com/2015/09/18/thebackendforfrontendpattern_bff.html">http://philcalcado.com/2015/09/18/thebackendforfrontendpattern_bff.html</a></li>
<li><a href="https://link.zhihu.com/?target=http://samnewman.io/patterns/architectural/bff">http://samnewman.io/patterns/architectural/bff</a></li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/netflix-techblog/embracing-the-differences-inside-the-netflix-api-redesign-15fd8b3dc49d">https://medium.com/netflix-techblog/embracing-the-differences-inside-the-netflix-api-redesign-15fd8b3dc49d</a></li>
</ul>
<p>参考项目</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wangyangyangisme/wolf-bff">https://github.com/wangyangyangisme/wolf-bff</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/wangyangyangisme/front-bff-msa">https://github.com/wangyangyangisme/front-bff-msa</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/wangyangyangisme/backend-bff">https://github.com/wangyangyangisme/backend-bff</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/wangyangyangisme/try-bff">https://github.com/wangyangyangisme/try-bff</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/wangyangyangisme/gospiga">https://github.com/wangyangyangisme/gospiga</a> redisrearch全文收索</p>
<p><strong>鉴权</strong></p>
<p>在官方的描述中，GraphQL和RESTful API一样，建议开发者将授权逻辑委托给业务逻辑层：</p>
<p><strong>n+1</strong></p>
<p>dataloader</p>
<p><a target="_blank" rel="noopener" href="https://github.com/vektah/dataloaden">https://github.com/vektah/dataloaden</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/graph-gophers/dataloader">https://github.com/graph-gophers/dataloader</a></p>
<p>相关文章</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/43dae0b83755">https://www.jianshu.com/p/43dae0b83755</a> REST服务与RestfulAPI风格<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/z69183787/article/details/79992285">https://blog.csdn.net/z69183787/article/details/79992285</a> 微服务下使用GraphQL构建BFF<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/798b610dca32">https://www.jianshu.com/p/798b610dca32</a> 使用 GraphQL 构建 BFF Demo<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1477870">https://cloud.tencent.com/developer/article/1477870</a> GraphQL-BFF：微服务背景下的前后端数据交互方案<br><a target="_blank" rel="noopener" href="https://www.sohu.com/a/235978606_205771">https://www.sohu.com/a/235978606_205771</a> 干货分享 | GraphQL 数据聚合层<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b420a33eeeab">https://www.jianshu.com/p/b420a33eeeab</a> GraphQL服务开发指南<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1336237">https://cloud.tencent.com/developer/article/1336237</a> 一位前端专家构建GraphQL工程的心路历程<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/44140864">https://zhuanlan.zhihu.com/p/44140864</a> 精读《REST, GraphQL, gRPC 如何选型》<br><a target="_blank" rel="noopener" href="https://github.com/maticzav/graphql-shield">https://github.com/maticzav/graphql-shield</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/141629697">https://zhuanlan.zhihu.com/p/141629697</a> 代码之上：我们落地 GraphQL 背后的故事<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45944392">https://zhuanlan.zhihu.com/p/45944392</a> 从头用go写一个GraphQL服务（3）OpenTracing追踪<br><a target="_blank" rel="noopener" href="https://haofly.net/graphql-tutorial-6/">https://haofly.net/graphql-tutorial-6/</a> n+1问题 <a target="_blank" rel="noopener" href="https://github.com/vektah/dataloaden">https://github.com/vektah/dataloaden</a>  <a target="_blank" rel="noopener" href="https://github.com/graph-gophers/dataloader">https://github.com/graph-gophers/dataloader</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wangyyovo.github.io">Blank</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wangyyovo.github.io/posts/12f3861c/">https://wangyyovo.github.io/posts/12f3861c/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wangyyovo.github.io" target="_blank">Blank</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/microservice/dc2b938ad73884759e1fba950951d998.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/260dbad6/" title="GraphQL文档"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/microservice/1975ab13a16d7203e5f79efb3e499123.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">GraphQL文档</div></div><div class="info-2"><div class="info-item-1"> GraphQL文档 https://graphql.cn/learn/   GraphQL 入门 在接下来的一系列文章中，我们会了解 GraphQL 是什么，它是如何运作以及如何使用它。在找如何搭建 GraphQL 服务的文档？这有一些类库可以帮你用多种不同语言实现 GraphQL。通过实用教程深入学习体验，请访问 How to GraphQL 全栈教程网站。我们还与 edX 合作创建了免费的在线课程，探索 GraphQL：一种用于 API 的查询语言。  GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。GraphQL 并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。 一个 GraphQL 服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的每个字段提供解析函数。例如，一个 GraphQL 服务告诉我们当前登录用户是 me，这个用户的名称可能像这样： 12345678type Query &#123;  me: User&#125;type User &#123;  id:...</div></div></div></a><a class="pagination-related" href="/posts/80988629/" title="autoxjs高级开发环境搭建"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/autojs/2e02e868832b346009a39a83d08a1cd2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">autoxjs高级开发环境搭建</div></div><div class="info-2"><div class="info-item-1"> 概述autoxjs 是继续维护升级的Auto.js 项目，在原来项目的基础上，实现了如下功能： [x] autoxjs 项目工程化：结合webpack vscode插件，开发、编译、打包、部署、混淆、加密一体化 文档资料[x] vscode 插件右键，自动提示操作等下载地址[x] vscode 自动补全、方法注释等， 文档资料[x] 发布新版autoxjs 4.2.1 ： 打包插件，运行apk、autox.js下载地址[x] 建设论坛、提供交流社区，交流社区 [ ] 建设应用商店[ ] 提供更好的sdk 封装 下面我主要对工程化、规划范化这块的环境搭建进行讲解： 优酷视频讲解 环境搭建 你需要安装 nodejs ，安装过程中请注意要 [ 将node添加PATH中 ] 和 安装 npm 这两个选项都要勾选上。(一般的前端工程师都有这个环节) 安装vscode 并安装 autoxjs开发插件即：Auto.js-VSCodeExt-Fixed 注意是0.3.11 或以上版本。 （ctr+ shift+p 选择autojs 启动服务） 安装全局安装 webpack： npm i -g ...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Blank</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">352</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>主题 GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8B%E4%BD%BF%E7%94%A8GraphQL%E6%9E%84%E5%BB%BABFF"><span class="toc-number">1.</span> <span class="toc-text">微服务下使用GraphQL构建BFF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GraphQL"><span class="toc-number">1.1.</span> <span class="toc-text">GraphQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GraphQL%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">GraphQL优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GraphQL-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">GraphQL 的优点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%9C%B0%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">声明式地数据获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-GraphQL-%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%BF%87%E5%BA%A6%E8%8E%B7%E5%8F%96"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">在 GraphQL 中没有过度获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-React%E3%80%81Angular%E3%80%81Node-%E5%92%8C-Co-%E4%B8%AD%E7%9A%84-GraphQL"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">在 React、Angular、Node 和 Co 中的 GraphQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">单一数据源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5-GraphQL-Schema"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">拼接 GraphQL Schema</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GraphQL-%E8%87%AA%E7%9C%81"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">GraphQL 自省</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%9A%84-GraphQL"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">强类型的 GraphQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GraphQL-%E7%89%88%E6%9C%AC%E5%8C%96"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">GraphQL 版本化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E9%95%BF%E4%B8%AD%E7%9A%84-GraphQL-%E7%94%9F%E6%80%81"><span class="toc-number">1.2.1.9.</span> <span class="toc-text">成长中的 GraphQL 生态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E5%BA%94%E8%AF%A5%E5%85%A8%E9%83%A8%E6%8A%95%E5%85%A5%E5%88%B0-GraphQL-%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.1.10.</span> <span class="toc-text">我应该全部投入到 GraphQL 么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GraphQL-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">GraphQL 的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GraphQL-%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">GraphQL 查询的复杂性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">查询频率限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GraphQL-%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">GraphQL 缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8-REST-%E5%91%A2%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">为什么不用 REST 呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFF-%E6%A6%82%E5%86%B5%E5%8F%8A%E6%BC%94%E8%BF%9B"><span class="toc-number">1.3.</span> <span class="toc-text">BFF 概况及演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B2%A1%E6%9C%89BFF-%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 没有BFF 的前后端架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A0%E5%85%A5%E4%BA%86BFF-%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 加入了BFF 的前后端架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFF-%E5%92%8C-API-Gateway"><span class="toc-number">1.4.</span> <span class="toc-text">BFF 和 API Gateway</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-API-Gateway-%E7%9A%84%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%B8%80%E4%B8%AA-API-Gateway-%E5%AF%B9%E6%89%80%E6%9C%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%90%E4%BE%9B%E5%90%8C%E4%B8%80%E7%A7%8D-API"><span class="toc-number">1.5.</span> <span class="toc-text">1. API Gateway 的第一种实现：一个 API Gateway 对所有客户端提供同一种 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-API-Gateway-%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%B8%80%E4%B8%AA-API-Gateway-%E5%AF%B9%E6%AF%8F%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%90%E4%BE%9B%E5%88%86%E5%88%AB%E7%9A%84-API"><span class="toc-number">1.6.</span> <span class="toc-text">2. API Gateway 的第二种实现：一个 API Gateway 对每种客户端提供分别的 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-API-Gateway-%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%A4%9A%E4%B8%AA-API-Gateway-%E5%88%86%E5%88%AB%E5%AF%B9%E6%AF%8F%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%90%E4%BE%9B%E5%88%86%E5%88%AB%E7%9A%84-API"><span class="toc-number">1.7.</span> <span class="toc-text">3. API Gateway 的第三种实现：多个 API Gateway 分别对每种客户端提供分别的 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GraphQL-%E4%B8%8E-REST"><span class="toc-number">1.8.</span> <span class="toc-text">GraphQL 与 REST</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%9A%E6%8C%89%E9%9C%80%E8%8E%B7%E5%8F%96"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 定义数据模型：按需获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B1%82"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 数据分层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 强类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8D%8F%E8%AE%AE%E8%80%8C%E9%9D%9E%E5%AD%98%E5%82%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">4. 协议而非存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%97%A0%E9%A1%BB%E7%89%88%E6%9C%AC%E5%8C%96"><span class="toc-number">1.8.5.</span> <span class="toc-text">5. 无须版本化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GraphQL-%E5%92%8C-REST"><span class="toc-number">1.8.6.</span> <span class="toc-text">GraphQL 和 REST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1-GraphQL-BFF-%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.9.</span> <span class="toc-text">微服务 + GraphQL + BFF 实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BFF-%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">1.9.1.</span> <span class="toc-text">1. BFF 端技术栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B4%E4%BD%93%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84"><span class="toc-number">1.9.2.</span> <span class="toc-text">2. 整体技术架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%89%B4%E6%9D%83%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.3.</span> <span class="toc-text">关于系统中的鉴权问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-GraphQL-BFF-%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.9.4.</span> <span class="toc-text">3. GraphQL + BFF 实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GraphQL-%E5%92%8C-BFF-%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%82%B9%E7%9A%84%E5%85%B3%E6%B3%A8"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">GraphQL 和 BFF 对业务点的关注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GraphQL-%E5%AF%B9%E7%89%88%E6%9C%AC%E5%8C%96%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">GraphQL 对版本化的支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GraphQL-Mutation-%E4%B8%8E-CQRS"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">GraphQL Mutation 与 CQRS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">1.9.4.4.</span> <span class="toc-text">如何做好测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">1.10.</span> <span class="toc-text">结语</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d14168d/" title="虚拟机问题合集"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/hexo/090cfe4e9e60b0ad0de05db822f3ae97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="虚拟机问题合集"/></a><div class="content"><a class="title" href="/posts/d14168d/" title="虚拟机问题合集">虚拟机问题合集</a><time datetime="2022-07-16T13:30:36.000Z" title="发表于 2022-07-16 21:30:36">2022-07-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f540045f/" title="用go语言编写移动端sdk和app开发"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/golang/941ed1ec2925719a0c92e76f4f786b6a.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用go语言编写移动端sdk和app开发"/></a><div class="content"><a class="title" href="/posts/f540045f/" title="用go语言编写移动端sdk和app开发">用go语言编写移动端sdk和app开发</a><time datetime="2022-07-04T12:14:21.000Z" title="发表于 2022-07-04 20:14:21">2022-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5faac006/" title="在线编程IDE"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/hexo/090cfe4e9e60b0ad0de05db822f3ae97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在线编程IDE"/></a><div class="content"><a class="title" href="/posts/5faac006/" title="在线编程IDE">在线编程IDE</a><time datetime="2022-06-12T13:30:36.000Z" title="发表于 2022-06-12 21:30:36">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7594185d/" title="即时性能分析工具Pyroscope"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/golang/3bfb3279740bc9a5b5ef436fa887ef07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="即时性能分析工具Pyroscope"/></a><div class="content"><a class="title" href="/posts/7594185d/" title="即时性能分析工具Pyroscope">即时性能分析工具Pyroscope</a><time datetime="2022-06-12T08:07:36.000Z" title="发表于 2022-06-12 16:07:36">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/82a7aa7c/" title="golang性能调试优化方法"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/common/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="golang性能调试优化方法"/></a><div class="content"><a class="title" href="/posts/82a7aa7c/" title="golang性能调试优化方法">golang性能调试优化方法</a><time datetime="2022-06-12T03:00:36.000Z" title="发表于 2022-06-12 11:00:36">2022-06-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Blank</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 5.4.2</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'BSfgwCPLOvPHVPaSoBCGSENf-MdYXbMMI',
      appKey: '2Q8qq5060qxycL6FPL26LnMG',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>