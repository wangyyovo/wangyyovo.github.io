<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NATS和NATS Streaming | Blank</title><meta name="author" content="Blank"><meta name="copyright" content="Blank"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NATS和NATS StreamingNATS源码安装 12345# Go clientgo get github.com&#x2F;nats-io&#x2F;nats.go&#x2F;# Servergo get github.com&#x2F;nats-io&#x2F;nats-server  二进制：https:&#x2F;&#x2F;nats.io&#x2F;download&#x2F;nats-io&#x2F;gnatsd&#x2F; When using or transitioning t">
<meta property="og:type" content="article">
<meta property="og:title" content="NATS和NATS Streaming">
<meta property="og:url" content="https://wangyyovo.github.io/posts/cd0e56c9/">
<meta property="og:site_name" content="Blank">
<meta property="og:description" content="NATS和NATS StreamingNATS源码安装 12345# Go clientgo get github.com&#x2F;nats-io&#x2F;nats.go&#x2F;# Servergo get github.com&#x2F;nats-io&#x2F;nats-server  二进制：https:&#x2F;&#x2F;nats.io&#x2F;download&#x2F;nats-io&#x2F;gnatsd&#x2F; When using or transitioning t">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/nats/939916bec37ea8f169680b4d133f4a86.jpg">
<meta property="article:published_time" content="2019-09-27T08:15:36.000Z">
<meta property="article:modified_time" content="2019-09-27T08:15:36.000Z">
<meta property="article:author" content="Blank">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/nats/939916bec37ea8f169680b4d133f4a86.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "NATS和NATS Streaming",
  "url": "https://wangyyovo.github.io/posts/cd0e56c9/",
  "image": "https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/nats/939916bec37ea8f169680b4d133f4a86.jpg",
  "datePublished": "2019-09-27T08:15:36.000Z",
  "dateModified": "2019-09-27T08:15:36.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Blank",
      "url": "https://wangyyovo.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/favicon.ico"><link rel="canonical" href="https://wangyyovo.github.io/posts/cd0e56c9/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Blank","link":"链接: ","source":"来源: Blank","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NATS和NATS Streaming',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="alternate" href="/atom.xml" title="Blank" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">352</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 教程</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/21cfbf15/"><span> 🚀 快速開始</span></a></li><li><a class="site-page child" href="/posts/dc584b87/"><span> 📑 主題頁面</span></a></li><li><a class="site-page child" href="/posts/4aa8abbe/"><span> 🛠 主題配置</span></a></li><li><a class="site-page child" href="/posts/ceeb73f/"><span> ⚔️ 標簽外挂</span></a></li><li><a class="site-page child" href="/posts/98d20436/"><span> ❓ 主題問答</span></a></li><li><a class="site-page child" href="/posts/4073eda/"><span> ⚡️ 進階教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/nats/939916bec37ea8f169680b4d133f4a86.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Blank</span></a><a class="nav-page-title" href="/"><span class="site-name">NATS和NATS Streaming</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 教程</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/21cfbf15/"><span> 🚀 快速開始</span></a></li><li><a class="site-page child" href="/posts/dc584b87/"><span> 📑 主題頁面</span></a></li><li><a class="site-page child" href="/posts/4aa8abbe/"><span> 🛠 主題配置</span></a></li><li><a class="site-page child" href="/posts/ceeb73f/"><span> ⚔️ 標簽外挂</span></a></li><li><a class="site-page child" href="/posts/98d20436/"><span> ❓ 主題問答</span></a></li><li><a class="site-page child" href="/posts/4073eda/"><span> ⚡️ 進階教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">NATS和NATS Streaming</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-09-27T08:15:36.000Z" title="发表于 2019-09-27 16:15:36">2019-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-09-27T08:15:36.000Z" title="更新于 2019-09-27 16:15:36">2019-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/microservice/">microservice</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/microservice/nats/">nats</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><script src="\assets\js\APlayer.min.js"> </script><h1 id="NATS和NATS-Streaming"><a href="#NATS和NATS-Streaming" class="headerlink" title="NATS和NATS Streaming"></a>NATS和NATS Streaming</h1><h2 id="NATS"><a href="#NATS" class="headerlink" title="NATS"></a>NATS</h2><p>源码安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Go client</span></span><br><span class="line">go get github.com/nats-io/nats.go/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Server</span></span><br><span class="line">go get github.com/nats-io/nats-server</span><br></pre></td></tr></table></figure>

<p>二进制：<a target="_blank" rel="noopener" href="https://nats.io/download/nats-io/gnatsd/">https://nats.io/download/nats-io/gnatsd/</a></p>
<p>When using or transitioning to Go modules support:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Go client latest or explicit version</span></span><br><span class="line">go get github.com/nats-io/nats.go/@latest</span><br><span class="line">go get github.com/nats-io/nats.go/@v1.9.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For latest NATS Server, add /v2 at the end</span></span><br><span class="line">go get github.com/nats-io/nats-server/v2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NATS Server v1 is installed otherwise</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go get github.com/nats-io/nats-server</span></span><br></pre></td></tr></table></figure>

<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nats <span class="string">&quot;github.com/nats-io/nats.go&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect to a server</span></span><br><span class="line">nc, _ := nats.Connect(nats.DefaultURL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Publisher</span></span><br><span class="line">nc.Publish(<span class="string">&quot;foo&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Async Subscriber</span></span><br><span class="line">nc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *nats.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Responding to a request message</span></span><br><span class="line">nc.Subscribe(<span class="string">&quot;request&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *nats.Msg)</span></span> &#123;</span><br><span class="line">    m.Respond([]<span class="type">byte</span>(<span class="string">&quot;answer is 42&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Sync Subscriber</span></span><br><span class="line">sub, err := nc.SubscribeSync(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">m, err := sub.NextMsg(timeout)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Channel Subscriber</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> *nats.Msg, <span class="number">64</span>)</span><br><span class="line">sub, err := nc.ChanSubscribe(<span class="string">&quot;foo&quot;</span>, ch)</span><br><span class="line">msg := &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsubscribe</span></span><br><span class="line">sub.Unsubscribe()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drain</span></span><br><span class="line">sub.Drain()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requests</span></span><br><span class="line">msg, err := nc.Request(<span class="string">&quot;help&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;help me&quot;</span>), <span class="number">10</span>*time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replies</span></span><br><span class="line">nc.Subscribe(<span class="string">&quot;help&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *nats.Msg)</span></span> &#123;</span><br><span class="line">    nc.Publish(m.Reply, []<span class="type">byte</span>(<span class="string">&quot;I can help!&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drain connection (Preferred for responders)</span></span><br><span class="line"><span class="comment">// Close() not needed if this is called.</span></span><br><span class="line">nc.Drain()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close connection</span></span><br><span class="line">nc.Close()</span><br></pre></td></tr></table></figure>

<h3 id="编码连接"><a href="#编码连接" class="headerlink" title="编码连接"></a>编码连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">nc, _ := nats.Connect(nats.DefaultURL)</span><br><span class="line">c, _ := nats.NewEncodedConn(nc, nats.JSON_ENCODER)</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Publisher</span></span><br><span class="line">c.Publish(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Async Subscriber</span></span><br><span class="line">c.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, s)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// EncodedConn can Publish any raw Go type using the registered Encoder</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">     Name     <span class="type">string</span></span><br><span class="line">     Address  <span class="type">string</span></span><br><span class="line">     Age      <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go type Subscriber</span></span><br><span class="line">c.Subscribe(<span class="string">&quot;hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(p *person)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a person: %+v\n&quot;</span>, p)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">me := &amp;person&#123;Name: <span class="string">&quot;derek&quot;</span>, Age: <span class="number">22</span>, Address: <span class="string">&quot;140 New Montgomery Street, San Francisco, CA&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go type Publisher</span></span><br><span class="line">c.Publish(<span class="string">&quot;hello&quot;</span>, me)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsubscribe</span></span><br><span class="line">sub, err := c.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">sub.Unsubscribe()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requests</span></span><br><span class="line"><span class="keyword">var</span> response <span class="type">string</span></span><br><span class="line">err = c.Request(<span class="string">&quot;help&quot;</span>, <span class="string">&quot;help me&quot;</span>, &amp;response, <span class="number">10</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Request failed: %v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replying</span></span><br><span class="line">c.Subscribe(<span class="string">&quot;help&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(subj, reply <span class="type">string</span>, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    c.Publish(reply, <span class="string">&quot;I can help!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close connection</span></span><br><span class="line">c.Close();</span><br></pre></td></tr></table></figure>

<h3 id="新身份验证-Nkeys-和用户凭据"><a href="#新身份验证-Nkeys-和用户凭据" class="headerlink" title="新身份验证 (Nkeys 和用户凭据)"></a>新身份验证 (Nkeys 和用户凭据)</h3><p>这需要服务器的版本&gt; &#x3D;2.0.0</p>
<p>NATS 服务器有一个新的安全和身份验证机制来使用用户凭据和 Nkeys 认证。 最简单的形式是使用方法 userciles（credsFilepath）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc, err := nats.Connect(url, nats.UserCredentials(<span class="string">&quot;user.creds&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>The helper methods creates two callback handlers to present the user  JWT and sign the nonce challenge from the server. The core client library never has direct access to your private key and  simply performs the callback for signing the server challenge. The helper will load and wipe and erase memory it uses for each connect  or reconnect.</p>
<p>The helper also can take two entries, one for the JWT and one for the NKey seed file.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc, err := nats.Connect(url, nats.UserCredentials(<span class="string">&quot;user.jwt&quot;</span>, <span class="string">&quot;user.nk&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>You can also set the callback handlers directly and manage challenge signing directly.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc, err := nats.Connect(url, nats.UserJWT(jwtCB, sigCB))</span><br></pre></td></tr></table></figure>

<p>Bare Nkeys are also supported. The nkey seed should be in a read only file, e.g. seed.txt</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">cat</span> seed.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is my seed nkey!</span></span><br><span class="line">SUAGMJH5XLGZKQQWAWKRZJIGMOU4HPFUYLXJMXOO5NLFEO2OOQJ5LPRDPM</span><br></pre></td></tr></table></figure>

<p>This is a helper function which will load and decode and do the proper signing for the server nonce. It will clear memory in between invocations. You can choose to use the low level option and provide the public key and a signature callback on your own.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opt, err := nats.NkeyOptionFromSeed(<span class="string">&quot;seed.txt&quot;</span>)</span><br><span class="line">nc, err := nats.Connect(serverUrl, opt)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Direct</span></span><br><span class="line">nc, err := nats.Connect(serverUrl, nats.Nkey(pubNkey, sigCB))</span><br></pre></td></tr></table></figure>

<h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tls as a scheme will enable secure connections by default. This will also verify the server name.</span></span><br><span class="line">nc, err := nats.Connect(<span class="string">&quot;tls://nats.demo.io:4443&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you are using a self-signed certificate, you need to have a tls.Config with RootCAs setup.</span></span><br><span class="line"><span class="comment">// We provide a helper method to make this case easier.</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">&quot;tls://localhost:4443&quot;</span>, nats.RootCAs(<span class="string">&quot;./configs/certs/ca.pem&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the server requires client certificate, there is an helper function for that too:</span></span><br><span class="line">cert := nats.ClientCert(<span class="string">&quot;./configs/certs/client-cert.pem&quot;</span>, <span class="string">&quot;./configs/certs/client-key.pem&quot;</span>)</span><br><span class="line">nc, err = nats.Connect(<span class="string">&quot;tls://localhost:4443&quot;</span>, cert)</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can also supply a complete tls.Config</span></span><br><span class="line"></span><br><span class="line">certFile := <span class="string">&quot;./configs/certs/client-cert.pem&quot;</span></span><br><span class="line">keyFile := <span class="string">&quot;./configs/certs/client-key.pem&quot;</span></span><br><span class="line">cert, err := tls.LoadX509KeyPair(certFile, keyFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Fatalf(<span class="string">&quot;error parsing X509 certificate/key pair: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config := &amp;tls.Config&#123;</span><br><span class="line">    ServerName: 	opts.Host,</span><br><span class="line">    Certificates: 	[]tls.Certificate&#123;cert&#125;,</span><br><span class="line">    RootCAs:    	pool,</span><br><span class="line">    MinVersion: 	tls.VersionTLS12,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nc, err = nats.Connect(<span class="string">&quot;nats://localhost:4443&quot;</span>, nats.Secure(config))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	t.Fatalf(<span class="string">&quot;Got an error on Connect with Secure Options: %+v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用-Go-通道"><a href="#使用-Go-通道" class="headerlink" title="使用 Go 通道"></a>使用 Go 通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nc, _ := nats.Connect(nats.DefaultURL)</span><br><span class="line">ec, _ := nats.NewEncodedConn(nc, nats.JSON_ENCODER)</span><br><span class="line"><span class="keyword">defer</span> ec.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">     Name     <span class="type">string</span></span><br><span class="line">     Address  <span class="type">string</span></span><br><span class="line">     Age      <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">recvCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *person)</span><br><span class="line">ec.BindRecvChan(<span class="string">&quot;hello&quot;</span>, recvCh)</span><br><span class="line"></span><br><span class="line">sendCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *person)</span><br><span class="line">ec.BindSendChan(<span class="string">&quot;hello&quot;</span>, sendCh)</span><br><span class="line"></span><br><span class="line">me := &amp;person&#123;Name: <span class="string">&quot;derek&quot;</span>, Age: <span class="number">22</span>, Address: <span class="string">&quot;140 New Montgomery Street&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send via Go channels</span></span><br><span class="line">sendCh &lt;- me</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive via Go channels</span></span><br><span class="line">who := &lt;- recvCh</span><br></pre></td></tr></table></figure>



<h3 id="通配符订阅"><a href="#通配符订阅" class="headerlink" title="通配符订阅"></a>通配符订阅</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;*&quot; matches any token, at any level of the subject.</span></span><br><span class="line">nc.Subscribe(<span class="string">&quot;foo.*.baz&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Msg received on [%s] : %s\n&quot;</span>, m.Subject, <span class="type">string</span>(m.Data));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">nc.Subscribe(<span class="string">&quot;foo.bar.*&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Msg received on [%s] : %s\n&quot;</span>, m.Subject, <span class="type">string</span>(m.Data));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;&gt;&quot; matches any length of the tail of a subject, and can only be the last token</span></span><br><span class="line"><span class="comment">// E.g. &#x27;foo.&gt;&#x27; will match &#x27;foo.bar&#x27;, &#x27;foo.bar.baz&#x27;, &#x27;foo.foo.bar.bax.22&#x27;</span></span><br><span class="line">nc.Subscribe(<span class="string">&quot;foo.&gt;&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Msg received on [%s] : %s\n&quot;</span>, m.Subject, <span class="type">string</span>(m.Data));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Matches all of the above</span></span><br><span class="line">nc.Publish(<span class="string">&quot;foo.bar.baz&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>))</span><br></pre></td></tr></table></figure>



<h3 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All subscriptions with the same queue name will form a queue group.</span></span><br><span class="line"><span class="comment">// Each message will be delivered to only one subscriber per queue group,</span></span><br><span class="line"><span class="comment">// using queuing semantics. You can have as many queue groups as you wish.</span></span><br><span class="line"><span class="comment">// Normal subscribers will continue to work as expected.</span></span><br><span class="line"></span><br><span class="line">nc.QueueSubscribe(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;job_workers&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(_ *Msg)</span></span> &#123;</span><br><span class="line">  received += <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flush connection to server, returns when all messages have been processed.</span></span><br><span class="line">nc.Flush()</span><br><span class="line">fmt.Println(<span class="string">&quot;All clear!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlushTimeout specifies a timeout value as well.</span></span><br><span class="line">err := nc.FlushTimeout(<span class="number">1</span>*time.Second)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;All clear!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Flushed timed out!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Auto-unsubscribe after MAX_WANTED messages received</span></span><br><span class="line"><span class="keyword">const</span> MAX_WANTED = <span class="number">10</span></span><br><span class="line">sub, err := nc.Subscribe(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">sub.AutoUnsubscribe(MAX_WANTED)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple connections</span></span><br><span class="line">nc1 := nats.Connect(<span class="string">&quot;nats://host1:4222&quot;</span>)</span><br><span class="line">nc2 := nats.Connect(<span class="string">&quot;nats://host2:4222&quot;</span>)</span><br><span class="line"></span><br><span class="line">nc1.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">nc2.Publish(<span class="string">&quot;foo&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;Hello World!&quot;</span>));</span><br></pre></td></tr></table></figure>



<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> servers = <span class="string">&quot;nats://localhost:1222, nats://localhost:1223, nats://localhost:1224&quot;</span></span><br><span class="line"></span><br><span class="line">nc, err := nats.Connect(servers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optionally set ReconnectWait and MaxReconnect attempts.</span></span><br><span class="line"><span class="comment">// This example means 10 seconds total per backend.</span></span><br><span class="line">nc, err = nats.Connect(servers, nats.MaxReconnects(<span class="number">5</span>), nats.ReconnectWait(<span class="number">2</span> * time.Second))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optionally disable randomization of the server pool</span></span><br><span class="line">nc, err = nats.Connect(servers, nats.DontRandomize())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup callbacks to be notified on disconnects, reconnects and connection closed.</span></span><br><span class="line">nc, err = nats.Connect(servers,</span><br><span class="line">	nats.DisconnectErrHandler(<span class="function"><span class="keyword">func</span><span class="params">(nc *nats.Conn, err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Got disconnected! Reason: %q\n&quot;</span>, err)</span><br><span class="line">	&#125;),</span><br><span class="line">	nats.ReconnectHandler(<span class="function"><span class="keyword">func</span><span class="params">(nc *nats.Conn)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Got reconnected to %v!\n&quot;</span>, nc.ConnectedUrl())</span><br><span class="line">	&#125;),</span><br><span class="line">	nats.ClosedHandler(<span class="function"><span class="keyword">func</span><span class="params">(nc *nats.Conn)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Connection closed. Reason: %q\n&quot;</span>, nc.LastError())</span><br><span class="line">	&#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// When connecting to a mesh of servers with auto-discovery capabilities,</span></span><br><span class="line"><span class="comment">// you may need to provide a username/password or token in order to connect</span></span><br><span class="line"><span class="comment">// to any server in that mesh when authentication is required.</span></span><br><span class="line"><span class="comment">// Instead of providing the credentials in the initial URL, you will use</span></span><br><span class="line"><span class="comment">// new option setters:</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">&quot;nats://localhost:4222&quot;</span>, nats.UserInfo(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// For token based authentication:</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">&quot;nats://localhost:4222&quot;</span>, nats.Token(<span class="string">&quot;S3cretT0ken&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can even pass the two at the same time in case one of the server</span></span><br><span class="line"><span class="comment">// in the mesh requires token instead of user name and password.</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">&quot;nats://localhost:4222&quot;</span>,</span><br><span class="line">    nats.UserInfo(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>),</span><br><span class="line">    nats.Token(<span class="string">&quot;S3cretT0ken&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that if credentials are specified in the initial URLs, they take</span></span><br><span class="line"><span class="comment">// precedence on the credentials specified through the options.</span></span><br><span class="line"><span class="comment">// For instance, in the connect call below, the client library will use</span></span><br><span class="line"><span class="comment">// the user &quot;my&quot; and password &quot;pwd&quot; to connect to localhost:4222, however,</span></span><br><span class="line"><span class="comment">// it will use username &quot;foo&quot; and password &quot;bar&quot; when (re)connecting to</span></span><br><span class="line"><span class="comment">// a different server URL that it got as part of the auto-discovery.</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">&quot;nats://my:pwd@localhost:4222&quot;</span>, nats.UserInfo(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="上下文支持-Go1-7"><a href="#上下文支持-Go1-7" class="headerlink" title="上下文支持 (+ Go1.7)"></a>上下文支持 (+ Go1.7)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">nc, err := nats.Connect(nats.DefaultURL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request with context</span></span><br><span class="line">msg, err := nc.RequestWithContext(ctx, <span class="string">&quot;foo&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;bar&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synchronous subscriber with context</span></span><br><span class="line">sub, err := nc.SubscribeSync(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">msg, err := sub.NextMsgWithContext(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encoded Request with context</span></span><br><span class="line">c, err := nats.NewEncodedConn(nc, nats.JSON_ENCODER)</span><br><span class="line"><span class="keyword">type</span> request <span class="keyword">struct</span> &#123;</span><br><span class="line">	Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> response <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">req := &amp;request&#123;Message: <span class="string">&quot;Hello&quot;</span>&#125;</span><br><span class="line">resp := &amp;response&#123;&#125;</span><br><span class="line">err := c.RequestWithContext(ctx, <span class="string">&quot;foo&quot;</span>, req, resp)</span><br></pre></td></tr></table></figure>

<h2 id="NATS-Streaming"><a href="#NATS-Streaming" class="headerlink" title="NATS Streaming"></a>NATS Streaming</h2><p>源码安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Go client</span></span><br><span class="line">go get github.com/nats-io/stan.go/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Server</span></span><br><span class="line">go get github.com/nats-io/nats-streaming-server</span><br></pre></td></tr></table></figure>

<p>二进制：<a target="_blank" rel="noopener" href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a></p>
<p>When using or transitioning to Go modules support:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Go client latest or explicit version</span></span><br><span class="line">go get github.com/nats-io/stan.go/@latest</span><br><span class="line">go get github.com/nats-io/stan.go/@v0.5.0</span><br></pre></td></tr></table></figure>

<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stan <span class="string">&quot;github.com/nats-io/stan.go&quot;</span></span><br><span class="line"></span><br><span class="line">sc, _ := stan.Connect(clusterID, clientID)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Synchronous Publisher</span></span><br><span class="line">sc.Publish(<span class="string">&quot;foo&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>)) <span class="comment">// does not return until an ack has been received from NATS Streaming</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Async Subscriber</span></span><br><span class="line">sub, _ := sc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsubscribe</span></span><br><span class="line">sub.Unsubscribe()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close connection</span></span><br><span class="line">sc.Close()</span><br></pre></td></tr></table></figure>

<h4 id="订阅启动-i-e-重播-选项"><a href="#订阅启动-i-e-重播-选项" class="headerlink" title="订阅启动 (i.e.重播)选项"></a>订阅启动 (i.e.重播)选项</h4><p>NATS Streaming subscriptions are similar to NATS subscriptions, but  clients may start their subscription at an earlier point in the message  stream, allowing them to receive messages that were published before  this client registered interest.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subscribe starting with most recently published value</span></span><br><span class="line">sub, err := sc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;, stan.StartWithLastReceived())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive all stored values in order</span></span><br><span class="line">sub, err := sc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;, stan.DeliverAllAvailable())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive messages starting at a specific sequence number</span></span><br><span class="line">sub, err := sc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;, stan.StartAtSequence(<span class="number">22</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe starting at a specific time</span></span><br><span class="line"><span class="keyword">var</span> startTime time.Time</span><br><span class="line">...</span><br><span class="line">sub, err := sc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;, stan.StartAtTime(startTime))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe starting a specific amount of time in the past (e.g. 30 seconds ago)</span></span><br><span class="line">sub, err := sc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;, stan.StartAtTimeDelta(time.ParseDuration(<span class="string">&quot;30s&quot;</span>)))</span><br></pre></td></tr></table></figure>

<h4 id="持久订阅"><a href="#持久订阅" class="headerlink" title="持久订阅"></a>持久订阅</h4><p>Replay of messages offers great flexibility for clients wishing to  begin processing at some earlier point in the data stream. However, some clients just need to pick up where they left off from an  earlier session, without having to manually track their position in the  stream of messages. Durable subscriptions allow clients to assign a durable name to a  subscription when it is created. Doing this causes the NATS Streaming server to track the last  acknowledged message for that clientID + durable name, so that only  messages since the last acknowledged message will be delivered to the  client.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sc, _ := stan.Connect(<span class="string">&quot;test-cluster&quot;</span>, <span class="string">&quot;client-123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe with durable name</span></span><br><span class="line">sc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;, stan.DurableName(<span class="string">&quot;my-durable&quot;</span>))</span><br><span class="line">...</span><br><span class="line"><span class="comment">// client receives message sequence 1-40</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// client disconnects for an hour</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// client reconnects with same clientID &quot;client-123&quot;</span></span><br><span class="line">sc, _ := stan.Connect(<span class="string">&quot;test-cluster&quot;</span>, <span class="string">&quot;client-123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// client re-subscribes to &quot;foo&quot; with same durable name &quot;my-durable&quot;</span></span><br><span class="line">sc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;, stan.DurableName(<span class="string">&quot;my-durable&quot;</span>))</span><br><span class="line">...</span><br><span class="line"><span class="comment">// client receives messages 41-current</span></span><br></pre></td></tr></table></figure>

<h4 id="队列组-1"><a href="#队列组-1" class="headerlink" title="队列组"></a>队列组</h4><p>所有具有相同队列名称的订阅（不管连接是什么） 它们起源于)将形成一个队列组。 每条消息将被传递给每个队列组只有一个订阅者， 使用队列语义。您可以希望有多少队列组。</p>
<p>正常的订户将继续按预期工作。</p>
<h5 id="创建队列组"><a href="#创建队列组" class="headerlink" title="创建队列组"></a>创建队列组</h5><p>当第一个队列订阅者是自动创建队列组 创建。如果组已经存在，则将成员添加到组。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sc, _ := stan.Connect(<span class="string">&quot;test-cluster&quot;</span>, <span class="string">&quot;clientid&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a queue subscriber on &quot;foo&quot; for group &quot;bar&quot;</span></span><br><span class="line">qsub1, _ := sc.QueueSubscribe(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, qcb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a second member</span></span><br><span class="line">qsub2, _ := sc.QueueSubscribe(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, qcb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notice that you can have a regular subscriber on that subject</span></span><br><span class="line">sub, _ := sc.Subscribe(<span class="string">&quot;foo&quot;</span>, cb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A message on &quot;foo&quot; will be received by sub and qsub1 or qsub2.</span></span><br></pre></td></tr></table></figure>

<h5 id="起始位置"><a href="#起始位置" class="headerlink" title="起始位置"></a>起始位置</h5><p>注意，一旦形成队列组，成员的起始位置就会被忽略 当加入小组时。它将开始接收消息从最后 在小组中的位置。</p>
<p>假设频道<code>foo</code>存在与存在<code>500</code>存储的消息组<code>bar</code>已经创建有两个成员和最后一个 消息序列发送<code>100</code>.增加了一个新成员。注意它的起始位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.QueueSubscribe(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, qcb, stan.StartAtSequence(<span class="number">200</span>))</span><br></pre></td></tr></table></figure>

<p>这不会产生错误，但是开始位置将被忽略。假定的 这个成员将是接收下一个消息的人它将接收消息 序列<code>101</code>. </p>
<h5 id="离开队列组"><a href="#离开队列组" class="headerlink" title="离开队列组"></a>离开队列组</h5><p> 离开组的方法有两种：关闭订阅者的连接或调用<code>Unsubscribe</code>： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Have qsub leave the queue group</span></span><br><span class="line">qsub.Unsubscribe()</span><br></pre></td></tr></table></figure>

<p>如果离开成员有未确认的消息，则重新分配这些消息 致其余的成员。 </p>
<h5 id="关闭队列组"><a href="#关闭队列组" class="headerlink" title="关闭队列组"></a>关闭队列组</h5><p>这方面没有特别的 API。一旦所有成员都离开了<code>Unsubscribe</code>, 或者他们的连接是关闭的），组从服务器中删除。</p>
<p>下一个要求<code>QueueSubscribe</code>使用相同的组名将创建一个全新的组 也就是说，开始位置将生效，交付将从那里开始。</p>
<h4 id="持久队列组"><a href="#持久队列组" class="headerlink" title="持久队列组"></a>持久队列组</h4><p>如上所述，对于非持久队列订阅者，当最后一个成员离开组， 那群人被撤走了。持久队列组允许您让所有成员离开但仍然 保持状态。当一个成员重新加入时，它从该组的最后一个位置开始。 </p>
<h5 id="创建持久队列组"><a href="#创建持久队列组" class="headerlink" title="创建持久队列组"></a>创建持久队列组</h5><p>持久队列组的创建方式与标准队列组的创建方式类似， 除了<code>DurableName</code>必须使用选项来指定持久性。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.QueueSubscribe(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, qcb, stan.DurableName(<span class="string">&quot;dur&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>A group called <code>dur:bar</code> (the concatenation of durable name and group name) is created in the server. This means two things:</p>
<ul>
<li>The character <code>:</code> is not allowed for a queue subscriber&#39;s durable name.</li>
<li>具有相同名称的持久和非持久队列组可以共存。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non durable queue subscriber on group &quot;bar&quot;</span></span><br><span class="line">qsub, _ := sc.QueueSubscribe(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, qcb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Durable queue subscriber on group &quot;bar&quot;</span></span><br><span class="line">durQsub, _ := sc.QueueSubscribe(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, qcb, stan.DurableName(<span class="string">&quot;mydurablegroup&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// The same message produced on &quot;foo&quot; would be received by both queue subscribers.</span></span><br></pre></td></tr></table></figure>

<h6 id="起始位置-1"><a href="#起始位置-1" class="headerlink" title="起始位置"></a>起始位置</h6><p>非持久队列订阅者的规则适用于持久订阅者。 </p>
<h6 id="离开队列组-1"><a href="#离开队列组-1" class="headerlink" title="离开队列组"></a>离开队列组</h6><p> 至于非持久队列订阅者，如果成员的连接已关闭，或如果<code>Unsubscribe</code>它的名称，成员离开组。任何未确认的消息 被转移到剩下的成员。查看关闭小组与非持久队列订户重要的区别 。 </p>
<h6 id="关闭队列组-1"><a href="#关闭队列组-1" class="headerlink" title="关闭队列组"></a>关闭队列组</h6><p>那<em>最后的</em>成员调用<code>Unsubscribe</code>将关闭 (那就是摧毁) 组所以如果你想保持持久的集团你不应该 呼叫<code>Unsubscribe</code>.</p>
<p>因此，与非持久队列订阅者不同，维护队列组是可能的 服务器中没有成员。当一个新成员重新加入持久队列组， 它将从团队离开的地方恢复实际上首先接收所有未被承认的信息 可能在最后一个成员离开时留下的消息。</p>
<h4 id="通配符订阅-1"><a href="#通配符订阅-1" class="headerlink" title="通配符订阅"></a>通配符订阅</h4><p>NATS 流媒体订阅<strong>不</strong>支持通配符。 </p>
<h3 id="高级用法-1"><a href="#高级用法-1" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="连接配置，如-TLS-等"><a href="#连接配置，如-TLS-等" class="headerlink" title="连接配置，如 TLS 等"></a>连接配置，如 TLS 等</h4><p>如果您想要更高级的配置底层 NATS 连接您将需要 创建一个 NATS 连接调用<code>stan.NatsConn()</code>选项并将该连接传递到<code>stan.Connect()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a NATS connection that you can configure the way you want</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">&quot;tls://localhost:4443&quot;</span>, nats.ClientCert(<span class="string">&quot;mycerts/client-cert.pem&quot;</span>, <span class="string">&quot;mycerts/client-key.pem&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> (err != <span class="literal">nil</span>)</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then pass it to the stan.Connect() call.</span></span><br><span class="line">sc, err = stan.Connect(<span class="string">&quot;test-cluster&quot;</span>, <span class="string">&quot;me&quot;</span>, stan.NatsConn(nc))</span><br><span class="line"><span class="keyword">if</span> (err != <span class="literal">nil</span>)</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that you will be responsible for closing the NATS Connection after the streaming</span></span><br><span class="line"><span class="comment">// connection has been closed.</span></span><br></pre></td></tr></table></figure>

<h4 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h4><p>NATS 流服务器和客户机之间没有直接连接，这对了解客户机是否仍然有效提出了挑战。 当客户端断开时流服务器不被通知因此调用的重要性<code>Close()</code>.服务器发送心跳 到客户端的私人收件箱如果它错过了一定数量的响应它将考虑客户端的连接丢失并删除它 从它的状态。</p>
<p>前版本<code>0.4.0</code>，客户端库没有将 PINS 发送到流服务器，以检测连接失败。这是有问题的 特别是如果应用程序从未发送数据（例如只有订阅）。图片的情况下一个客户连接到一个 NATS 服务器有一条通往 NATS 流服务器的路径（连接到独立的 NATS 服务器或它嵌入的服务器）。如果 流服务器和客户端的 NATS 服务器之间的连接中断，客户端的 NATS 连接仍然可以，但是没有 与流服务器通信是可能的。这就是为什么依赖<code>Conn.NatsConn()</code>检查状态是没有帮助的。</p>
<p>开始版本<code>0.4.0</code>这个库和服务器的<code>0.10.0</code>，客户端库现在将定期发送 PING（默认为5秒） 并将关闭流连接后，一定数量的 PINS 已发送没有任何响应（默认是3）。当那时候 碰巧，回调（如果注册了）将被调用，以通知用户连接永久丢失，以及原因 因为失败了。</p>
<p>以下是您将如何指定自己的 PING 值和回调：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send PINGs every 10 seconds, and fail after 5 PINGs without any response.</span></span><br><span class="line">sc, err := stan.Connect(clusterName, clientName,</span><br><span class="line">  	stan.Pings(<span class="number">10</span>, <span class="number">5</span>),    </span><br><span class="line">  	stan.SetConnectionLostHandler(<span class="function"><span class="keyword">func</span><span class="params">(_ stan.Conn, reason <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    	log.Fatalf(<span class="string">&quot;Connection lost, reason: %v&quot;</span>, reason)</span><br><span class="line">	&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>注意，要通知的唯一方法是设置回调。如果没有设置回调，则仍然发送 PING 和连接 如果需要，将关闭，但应用程序将不知道它是否只有订阅。</p>
<p>当连接丢失时，应用程序将不得不重新创建它和所有订阅（如果有的话）。</p>
<p>当没有 NATS 连接提供给<code>Connect()</code>调用，库创建它自己的 NATS 连接，现在将 将重新连接尝试设置为 “无限”，以前不是这样的。因此图书馆应该有可能 总是重新连接但这并不意味着流连接不会被关闭即使您设置的非常高 PINS 的阈值最大输出值。请记住，当客户端断开时，服务器正在向其发送心跳信号 客户机也是如此，当没有得到任何响应时，它将把客户机从它的状态中删除。当通信恢复时， 发送到服务器的 PINS 将允许检测此条件并向客户机报告连接现在已关闭。</p>
<p>此外，当客户机与服务器 “断开连接” 时，另一个连接到流服务器的应用程序可能会 连接并使用相同的客户端 ID。当检测重复的客户端 ID 时服务器将尝试与第一个客户端联系 要知道它是否应该拒绝第二个客户端的连接请求。由于通信之间的服务器和 第一个客户机被破坏，服务器将得不到响应，因此将用第二个客户机替换第一个客户机。</p>
<p>在客户之前<code>0.4.0</code>与服务器<code>0.10.0</code>，如果要恢复第一个客户机和服务器之间的通信， 而应用程序将发送消息服务器将接受这些消息因为发布的消息客户端 ID 是 有效，尽管客户端是无效的。与客户在<code>0.4.0+</code>与服务器<code>0.10.0+</code>，每个人都会发送更多的信息 消息，允许服务器拒绝来自已被另一个客户机替换的客户机的消息。</p>
<h4 id="异步发布"><a href="#异步发布" class="headerlink" title="异步发布"></a>异步发布</h4><p>基本发布 API (<code>Publish(subject, payload)</code>)是同步的;在 NATS 流服务器确认收到消息之前，它不会将控制返回给调用者。为了做到这一点<a target="_blank" rel="noopener" href="https://github.com/nats-io/nuid">nuid</a>是为创建时的消息生成的，客户端库在服务器返回控制权给调用者之前等待来自服务器的发布确认，这可能是由于服务器问题或授权错误导致操作不成功的错误。</p>
<p>高级用户可能希望手动处理这些发布确认，通过在发布操作期间不等待单个确认来实现更高的发布吞吐量。为此提供了异步发布 API：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ackHandler := <span class="function"><span class="keyword">func</span><span class="params">(ackedNuid <span class="type">string</span>, err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Warning: error publishing msg id %s: %v\n&quot;</span>, ackedNuid, err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Received ack for msg id %s\n&quot;</span>, ackedNuid)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nuid, err := sc.PublishAsync(<span class="string">&quot;foo&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>), ackHandler) <span class="comment">// returns immediately</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Error publishing msg %s: %v\n&quot;</span>, nuid, err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息确认和回复"><a href="#消息确认和回复" class="headerlink" title="消息确认和回复"></a>消息确认和回复</h4><p>NATS 流提供了至少一次交付语义，这意味着一旦消息被传递给了合格的订阅者，如果在配置的超时间隔内没有接收到确认，NATS 流将尝试重新发送消息。 此超时间隔由订阅选项指定<code>AckWait</code>，默认为30秒。</p>
<p>默认情况下，在调用订阅服务器的消息处理程序后，NATS 流客户端库自动确认消息。但是，在某些情况下，订阅客户端希望加速或延迟对消息的确认。 要做到这一点，客户端必须在订阅上设置手动确认模式，并调用<code>Ack()</code>关于<code>Msg</code>. 例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subscribe with manual ack mode, and set AckWait to 60 seconds</span></span><br><span class="line">aw, _ := time.ParseDuration(<span class="string">&quot;60s&quot;</span>)</span><br><span class="line">sub, err := sc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">  m.Ack() <span class="comment">// ack message before performing I/O intensive operation</span></span><br><span class="line">  <span class="comment">///...</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;Received a message: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">&#125;, stan.SetManualAckMode(), stan.AckWait(aw))</span><br></pre></td></tr></table></figure>

<h3 id="速率限制-匹配"><a href="#速率限制-匹配" class="headerlink" title="速率限制&#x2F;匹配"></a>速率限制&#x2F;匹配</h3><p> 发布-订阅消息传递的一个经典问题是消息生产者的速率与消息使用者的速率匹配。 消息生成程序通常可以超过使用它们的消息的订阅者的速度。 这种不匹配通常被称为 “快速生产者&#x2F;慢消费者” 问题，并可能导致底层消息传递系统的资源利用率急剧上升，因为它试图缓冲消息，直到慢消费者能够赶上。 </p>
<h4 id="发布者速率限制"><a href="#发布者速率限制" class="headerlink" title="发布者速率限制"></a>发布者速率限制</h4><p>NATS 流提供了一个名为连接选项<code>MaxPubAcksInflight</code>这有效地限制了发布者在任何给定时间内可能有的未确认消息的数量。当达到这个最大值时进一步<code>PublishAsync()</code>调用将阻塞，直到未确认消息的数量低于指定的限制。 例： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sc, _ := stan.Connect(clusterID, clientID, MaxPubAcksInflight(<span class="number">25</span>))</span><br><span class="line"></span><br><span class="line">ah := <span class="function"><span class="keyword">func</span><span class="params">(nuid <span class="type">string</span>, err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// process the ack</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    <span class="comment">// If the server is unable to keep up with the publisher, the number of outstanding acks will eventually</span></span><br><span class="line">    <span class="comment">// reach the max and this call will block</span></span><br><span class="line">    guid, _ := sc.PublishAsync(<span class="string">&quot;foo&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>), ah)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用户速率限制"><a href="#用户速率限制" class="headerlink" title="用户速率限制"></a>用户速率限制</h4><p>使用称为订阅选项的订阅选项也可以在订阅方按每次订阅的方式实现速率限制<code>MaxInflight</code>. 此选项指定 NATS 流允许给定订阅的未完成确认（已交付但未确认的消息）的最大数量。 当达到此限制时，NATS 流将暂停向此订阅交付消息，直到未确认消息的数量低于指定的限制。 例： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subscribe with manual ack mode and a max in-flight limit of 25</span></span><br><span class="line">sc.Subscribe(<span class="string">&quot;foo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Received message #: %s\n&quot;</span>, <span class="type">string</span>(m.Data))</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Does not ack, or takes a very long time to ack</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Message delivery will suspend when the number of unacknowledged messages reaches 25</span></span><br><span class="line">&#125;, stan.SetManualAckMode(), stan.MaxInflight(<span class="number">25</span>))</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wangyyovo.github.io">Blank</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wangyyovo.github.io/posts/cd0e56c9/">https://wangyyovo.github.io/posts/cd0e56c9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wangyyovo.github.io" target="_blank">Blank</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/nats/939916bec37ea8f169680b4d133f4a86.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/ae51dde1/" title="NATS与NSQ的介绍和比较"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/nats/117253db2af95b52a584feae021fb1f8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">NATS与NSQ的介绍和比较</div></div><div class="info-2"><div class="info-item-1"> 轻量消息中间件NATS与NSQ的介绍和比较NATS1. 语言server：GO官方支持client库：GO、C等 2. 设计特点高效稳定可用轻量支持多种消息策略（at-most-once，at-least-once）支持多种模式streaming下提供可配置的消息持久化 3. 多种消息发布模式生产-消费（发布-订阅）模式 一对多两种策略：at-most-once（只保证w&#x2F;tcp的可靠性）：消息无接受者时，则该消息丢失。即消息发送后不关心是否有接收。该策略以降低可靠性换取了性能（吞吐量）。可靠性由使用者自行设计保证。at-least-once：在消息可靠性要求更高的场合，使用nats streaming。监控消息是否到达每一个订阅者。降低性能（吞吐量）换取可靠性。 请求-响应模式 点对点&#x2F;一对多。发布者发布消息需要收到响应。接受者可提前将响应放入“信箱”中。发布者只接收第一个响应。（如何配置一对多模型接收多个响应？） 队列订阅与协同工作 订阅的不是主题，而是队列。是一种负载均衡和容灾策略。队列中每个消息，随机发给一个订阅者。订阅者数量可随时增减。 （具体如何...</div></div></div></a><a class="pagination-related" href="/posts/e845c472/" title="NATS Streaming"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/nats/95994a9aea31be452e66c89e68ba4a27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">NATS Streaming</div></div><div class="info-2"><div class="info-item-1"> NATS StreamingNATS Streaming 概念NATS Streaming是一个由NATS驱动的数据流系统，用Go编程语言编写。 NATS Streaming服务器的可执行文件名是nats-streaming-server。 NATS Streaming与核心NATS平台无缝嵌入，扩展和互操作。 NATS Streaming服务器作为Apache-2.0许可下的开源软件提供。 Synadia积极维护和支持NATS Streaming服务器。 特点除了核心NATS平台的功能外，NATS Streaming还提供以下功能：  增强的消息协议 - NATS Streaming使用谷歌协议缓冲区实现自己的增强型消息格式。这些消息通过二进制数据流在NATS核心平台进行传播,因此不需要改变NATS的基本协议。NATS Streaming信息包含以下字段: 序列 - 一个全局顺序序列号为主题的通道　　- 主题 - 是NATS Streaming 交付对象　　- 答复内容 - 对应&quot;reply-to&quot;对应的对象内容　　- 数据 - 真是数据内容　　- 时间戳...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Blank</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">352</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>主题 GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NATS%E5%92%8CNATS-Streaming"><span class="toc-number">1.</span> <span class="toc-text">NATS和NATS Streaming</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NATS"><span class="toc-number">1.1.</span> <span class="toc-text">NATS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">编码连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81-Nkeys-%E5%92%8C%E7%94%A8%E6%88%B7%E5%87%AD%E6%8D%AE"><span class="toc-number">1.1.3.</span> <span class="toc-text">新身份验证 (Nkeys 和用户凭据)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS"><span class="toc-number">1.1.4.</span> <span class="toc-text">TLS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Go-%E9%80%9A%E9%81%93"><span class="toc-number">1.1.5.</span> <span class="toc-text">使用 Go 通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AE%A2%E9%98%85"><span class="toc-number">1.1.6.</span> <span class="toc-text">通配符订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%BB%84"><span class="toc-number">1.1.7.</span> <span class="toc-text">队列组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.8.</span> <span class="toc-text">高级用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.9.</span> <span class="toc-text">集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%94%AF%E6%8C%81-Go1-7"><span class="toc-number">1.1.10.</span> <span class="toc-text">上下文支持 (+ Go1.7)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NATS-Streaming"><span class="toc-number">1.2.</span> <span class="toc-text">NATS Streaming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E5%90%AF%E5%8A%A8-i-e-%E9%87%8D%E6%92%AD-%E9%80%89%E9%A1%B9"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">订阅启动 (i.e.重播)选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E8%AE%A2%E9%98%85"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">持久订阅</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%BB%84-1"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">队列组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97%E7%BB%84"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">创建队列组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">起始位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%BB%E5%BC%80%E9%98%9F%E5%88%97%E7%BB%84"><span class="toc-number">1.2.1.3.3.</span> <span class="toc-text">离开队列组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E9%98%9F%E5%88%97%E7%BB%84"><span class="toc-number">1.2.1.3.4.</span> <span class="toc-text">关闭队列组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E9%98%9F%E5%88%97%E7%BB%84"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">持久队列组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%81%E4%B9%85%E9%98%9F%E5%88%97%E7%BB%84"><span class="toc-number">1.2.1.4.1.</span> <span class="toc-text">创建持久队列组</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE-1"><span class="toc-number">1.2.1.4.1.1.</span> <span class="toc-text">起始位置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A6%BB%E5%BC%80%E9%98%9F%E5%88%97%E7%BB%84-1"><span class="toc-number">1.2.1.4.1.2.</span> <span class="toc-text">离开队列组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E9%98%9F%E5%88%97%E7%BB%84-1"><span class="toc-number">1.2.1.4.1.3.</span> <span class="toc-text">关闭队列组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AE%A2%E9%98%85-1"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">通配符订阅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%A6%82-TLS-%E7%AD%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">连接配置，如 TLS 等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">连接状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8F%91%E5%B8%83"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">异步发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E5%92%8C%E5%9B%9E%E5%A4%8D"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">消息确认和回复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6-%E5%8C%B9%E9%85%8D"><span class="toc-number">1.2.3.</span> <span class="toc-text">速率限制&#x2F;匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%80%85%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">发布者速率限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">用户速率限制</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d14168d/" title="虚拟机问题合集"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/hexo/090cfe4e9e60b0ad0de05db822f3ae97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="虚拟机问题合集"/></a><div class="content"><a class="title" href="/posts/d14168d/" title="虚拟机问题合集">虚拟机问题合集</a><time datetime="2022-07-16T13:30:36.000Z" title="发表于 2022-07-16 21:30:36">2022-07-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f540045f/" title="用go语言编写移动端sdk和app开发"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/golang/941ed1ec2925719a0c92e76f4f786b6a.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用go语言编写移动端sdk和app开发"/></a><div class="content"><a class="title" href="/posts/f540045f/" title="用go语言编写移动端sdk和app开发">用go语言编写移动端sdk和app开发</a><time datetime="2022-07-04T12:14:21.000Z" title="发表于 2022-07-04 20:14:21">2022-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5faac006/" title="在线编程IDE"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/hexo/090cfe4e9e60b0ad0de05db822f3ae97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在线编程IDE"/></a><div class="content"><a class="title" href="/posts/5faac006/" title="在线编程IDE">在线编程IDE</a><time datetime="2022-06-12T13:30:36.000Z" title="发表于 2022-06-12 21:30:36">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7594185d/" title="即时性能分析工具Pyroscope"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/golang/3bfb3279740bc9a5b5ef436fa887ef07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="即时性能分析工具Pyroscope"/></a><div class="content"><a class="title" href="/posts/7594185d/" title="即时性能分析工具Pyroscope">即时性能分析工具Pyroscope</a><time datetime="2022-06-12T08:07:36.000Z" title="发表于 2022-06-12 16:07:36">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/82a7aa7c/" title="golang性能调试优化方法"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/common/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="golang性能调试优化方法"/></a><div class="content"><a class="title" href="/posts/82a7aa7c/" title="golang性能调试优化方法">golang性能调试优化方法</a><time datetime="2022-06-12T03:00:36.000Z" title="发表于 2022-06-12 11:00:36">2022-06-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Blank</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 5.4.2</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"placeholder":"请留下你的脚印","pageSize":10,"lang":"zh-CN"}

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'BSfgwCPLOvPHVPaSoBCGSENf-MdYXbMMI',
      appKey: '2Q8qq5060qxycL6FPL26LnMG',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>