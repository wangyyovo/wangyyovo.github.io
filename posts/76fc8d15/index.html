<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>阿里COLA2.0架构 | Blank</title><meta name="author" content="Blank"><meta name="copyright" content="Blank"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="https:&#x2F;&#x2F;blog.csdn.net&#x2F;significantfrank&#x2F;article&#x2F;details&#x2F;100074716 COLA 3.0的源代码在：https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;COLA&#x2F;  很多同学不止一次和我反馈，我们的系统很混乱，主要表现在：  应用的层次结构混乱：不知道应用应该如何分层、应该包含哪些组件、组件之间的关系是什么； 缺少规范的指导和约束：新">
<meta property="og:type" content="article">
<meta property="og:title" content="阿里COLA2.0架构">
<meta property="og:url" content="https://wangyyovo.github.io/posts/76fc8d15/">
<meta property="og:site_name" content="Blank">
<meta property="og:description" content="https:&#x2F;&#x2F;blog.csdn.net&#x2F;significantfrank&#x2F;article&#x2F;details&#x2F;100074716 COLA 3.0的源代码在：https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;COLA&#x2F;  很多同学不止一次和我反馈，我们的系统很混乱，主要表现在：  应用的层次结构混乱：不知道应用应该如何分层、应该包含哪些组件、组件之间的关系是什么； 缺少规范的指导和约束：新">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/2b1dba393544c73910d963c2fac19f85.jpg">
<meta property="article:published_time" content="2020-10-14T03:27:36.000Z">
<meta property="article:modified_time" content="2020-10-14T03:27:36.000Z">
<meta property="article:author" content="Blank">
<meta property="article:tag" content="architecture">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/2b1dba393544c73910d963c2fac19f85.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "阿里COLA2.0架构",
  "url": "https://wangyyovo.github.io/posts/76fc8d15/",
  "image": "https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/2b1dba393544c73910d963c2fac19f85.jpg",
  "datePublished": "2020-10-14T03:27:36.000Z",
  "dateModified": "2020-10-14T03:27:36.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Blank",
      "url": "https://wangyyovo.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/favicon.ico"><link rel="canonical" href="https://wangyyovo.github.io/posts/76fc8d15/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Blank","link":"链接: ","source":"来源: Blank","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '阿里COLA2.0架构',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="alternate" href="/atom.xml" title="Blank" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">352</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 教程</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/21cfbf15/"><span> 🚀 快速開始</span></a></li><li><a class="site-page child" href="/posts/dc584b87/"><span> 📑 主題頁面</span></a></li><li><a class="site-page child" href="/posts/4aa8abbe/"><span> 🛠 主題配置</span></a></li><li><a class="site-page child" href="/posts/ceeb73f/"><span> ⚔️ 標簽外挂</span></a></li><li><a class="site-page child" href="/posts/98d20436/"><span> ❓ 主題問答</span></a></li><li><a class="site-page child" href="/posts/4073eda/"><span> ⚡️ 進階教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/2b1dba393544c73910d963c2fac19f85.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Blank</span></a><a class="nav-page-title" href="/"><span class="site-name">阿里COLA2.0架构</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 教程</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/21cfbf15/"><span> 🚀 快速開始</span></a></li><li><a class="site-page child" href="/posts/dc584b87/"><span> 📑 主題頁面</span></a></li><li><a class="site-page child" href="/posts/4aa8abbe/"><span> 🛠 主題配置</span></a></li><li><a class="site-page child" href="/posts/ceeb73f/"><span> ⚔️ 標簽外挂</span></a></li><li><a class="site-page child" href="/posts/98d20436/"><span> ❓ 主題問答</span></a></li><li><a class="site-page child" href="/posts/4073eda/"><span> ⚡️ 進階教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">阿里COLA2.0架构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-14T03:27:36.000Z" title="发表于 2020-10-14 11:27:36">2020-10-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-14T03:27:36.000Z" title="更新于 2020-10-14 11:27:36">2020-10-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/architecture/">architecture</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><script src="\assets\js\APlayer.min.js"> </script><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/significantfrank/article/details/100074716">https://blog.csdn.net/significantfrank/article/details/100074716</a></p>
<p>COLA 3.0的源代码在：<a target="_blank" rel="noopener" href="https://github.com/alibaba/COLA/">https://github.com/alibaba/COLA/</a></p>
</blockquote>
<p>很多同学不止一次和我反馈，我们的系统很混乱，主要表现在：</p>
<ul>
<li>应用的层次结构混乱：不知道应用应该如何分层、应该包含哪些组件、组件之间的关系是什么；</li>
<li>缺少规范的指导和约束：新加一段业务逻辑不知道放在什么地方（哪个类，哪个包）、应该起什么名字比较合适？</li>
</ul>
<p>解决这些问题，正是我创建COLA的初心之一——<strong>试图探索一套切实可行的应用架构规范，这个规范不是高高在上的纸上谈兵，而是可以复制、可以理解、可以落地、可以控制复杂性的指导和约束</strong>。</p>
<p>自从COLA诞生以来，我收到了很多的意见和建议。同时，我自己在实践过程中，也发现<a target="_blank" rel="noopener" href="https://blog.csdn.net/significantfrank/article/details/85785565">COLA 1.0</a>的诸多不足，有些设计是冗余的并不是很有必要，而有些关键要素并没有囊括。譬如，我最近的思考<a target="_blank" rel="noopener" href="https://blog.csdn.net/significantfrank/article/details/94593620">应用架构核心</a>和<a target="_blank" rel="noopener" href="https://blog.csdn.net/significantfrank/article/details/98087611">复杂业务代码治理</a>就是对COLA 1.0的反思。</p>
<p>结合实践中的探索和对复杂度治理持续的思考，我决定对COLA进行一次全面的升级，于是有了现在的COLA 2.0。<br>从1.0到2.0，不仅仅是数字的简单变化，更是架构理念和设计理念的升级，其主要变动点包括：</p>
<ul>
<li><strong>新架构分层</strong>：Domain层不再直接依赖Infrastructure层。</li>
<li><strong>新组件划分</strong>：对组件进行了重新定义和划分，加了新组件，去除了一些老组件（Validator，Convertor等）。</li>
<li><strong>新扩展点设计</strong>：引入了新概念，让扩展更加灵活。</li>
<li><strong>新二方库定位</strong>：二方库不仅仅是DTO，也是Domain Model的轻量级表达和实现。</li>
</ul>
<h1 id="新架构分层"><a href="#新架构分层" class="headerlink" title="新架构分层"></a>新架构分层</h1><p>在COLA 1.0中，我们的分层是如下图所示的经典分层结构：<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0.png" alt="image.png"></p>
<p>在COLA 2.0中，还是这些层次，但是依赖关系发生了变化，Domain层不再直接依赖Infrastructure层，而是引入了一个Gateway的概念，使用DIP（Dependency Inversion Principle，依赖倒置）反转了Domain层和Infrastructure层的依赖关系，其关系如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-2.png" alt="image.png"></p>
<p>这样做的好处是Domain层会变得更加纯粹，完全摆脱了对技术细节（以及技术细节带来的复杂度）的依赖，只需要安心处理业务逻辑就好了。</p>
<p>除此之外，还有两个好处：<br><strong>1. 并行开发</strong>：只要在Domain和Infrastructure约定好接口，可以有两个同学并行编写Domain和Infrastructure的代码。</p>
<p><strong>2. 可测试性</strong>：没有任何依赖的Domain里面都是POJO的类，单元测试将会变得非常方便，也非常适合TDD的开发。</p>
<h1 id="新组件划分"><a href="#新组件划分" class="headerlink" title="新组件划分"></a>新组件划分</h1><h2 id="模块和组件的定义"><a href="#模块和组件的定义" class="headerlink" title="模块和组件的定义"></a>模块和组件的定义</h2><p>首先，先明确一下组件（Component）这个概念的定义，组件在Java中（或者说在本文中），其范围就是Java的包（Package）。</p>
<p>还有一个词叫模块（Module），组件和模块这两个概念是比较容易发生混淆的。比如在《实现领域驱动设计》中，作者就说：</p>
<blockquote>
<p>If you are using Java or C#, you are already familiar with <strong>Modules</strong>, though you know them by another name. Java calls them packages. C# calls them namespaces.</p>
</blockquote>
<p>他认为Module是Package，我认为这个定义容易造成混淆。特别是在使用Maven的时候，在Maven中，Module是一个Artifact，通常是一个Jar而不是Package。比如COLA Framework就包括如下四个Module：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">module</span>&gt;</span>cola-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">module</span>&gt;</span>cola-core<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">module</span>&gt;</span>cola-extension<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">module</span>&gt;</span>cola-test<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>的确，Module和Component这两个概念很相近，很容易造成混淆。比如，在<a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/178927/is-there-a-difference-between-a-component-and-a-module">StackOverflow上有一个提问</a>，就是问Module和Component之间区别的。获得最高赞的答案是通过Scope来区分的。</p>
<blockquote>
<p>The terms are similar. I generally think of a “module” as being larger than a “component”. A component is a single part, usually relatively small in scope.</p>
</blockquote>
<p>这个回答和我的直觉反应是一致的，即Module比Component要大。根据以上信息，我在此对Module和Component进行一下定义说明，在本文中，都会遵照如下的定义和Notation（表示法）。</p>
<ul>
<li><strong>模块（Module）</strong>： 和Maven中Module定义保持一致，简单理解就是Jar。用正方体表示。</li>
<li><strong>组件（Component）</strong>：和UML中的定义类似，简单理解就是Package。用UML的组件图表示。</li>
</ul>
<p>一个Moudle通常是由多个Component组成的，其关系和表示法如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-3.png" alt="image.png"></p>
<h2 id="COLA-2-0的组件"><a href="#COLA-2-0的组件" class="headerlink" title="COLA 2.0的组件"></a>COLA 2.0的组件</h2><p>在COLA 2.0中，我们重新设计了组件，引入了一些新的组件，也去除了一些旧组件。这些变动的宗旨是为了让应用结构更加清晰，组件的职责更加明确，从而更好的提供开发指导和约束。</p>
<p>新的组件结构如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-4.png" alt="image.png"></p>
<p>这些组件各自都有自己的职责范围，组件的职责是COLA的重要组成部分，也就是我们上面说的“指导和约束”。这些组件的详细职责描述如下：</p>
<ol>
<li><strong>二方库里的组件</strong><ul>
<li>api：存放的是应用对外的接口。</li>
<li>dto.domainmodel：用来做数据传输的轻量级领域对象。</li>
<li>dto.domainevent: 用来做数据传输的领域事件。</li>
</ul>
</li>
<li><strong>Application里的组件</strong><ul>
<li>service：接口实现的facade，没有业务逻辑，可以包含对不同终端的adapter。</li>
<li>eventhandler：处理领域事件，包括本域的和外域的。</li>
<li>executor：用来处理命令（Command）和查询（Query），对复杂业务，可以包含<a target="_blank" rel="noopener" href="https://blog.csdn.net/significantfrank/article/details/100074716">Phase和Step</a>。</li>
<li>interceptor: COLA提供的对所有请求的AOP处理机制。</li>
</ul>
</li>
<li><strong>Domain里的组件</strong><ul>
<li>domain：领域实体，允许继承domainmodel。</li>
<li>domainservice: 领域服务，用来提供更粗粒度的领域能力。</li>
<li>gateway：对外依赖的网关接口，包括存储、RPC、Search等。</li>
</ul>
</li>
<li><strong>Infrastructure里的组件</strong><ul>
<li>config：配置信息相关。</li>
<li>message：消息处理相关。</li>
<li>repository：存储相关，是gateway的特化，主要用来做本域的数据CRUD操作。</li>
<li>gateway：对外依赖的网关接口（Domain里的gateway）的实现。</li>
</ul>
</li>
</ol>
<p>在使用COLA的时候，请尽量按照组件规范约束去构建我们的应用。这样可以让我们的应用结构清晰、有章可循。如此这般，代码的可维护性和可理解性会得到极大的提升。</p>
<h1 id="新扩展点设计"><a href="#新扩展点设计" class="headerlink" title="新扩展点设计"></a>新扩展点设计</h1><h2 id="引入新概念"><a href="#引入新概念" class="headerlink" title="引入新概念"></a>引入新概念</h2><p>在讨论之前，我们先来明确一下在COLA2.0扩展设计中引入的新概念：业务、用例、场景。</p>
<ul>
<li><strong>业务（Business）</strong>：就是一个自负盈亏的财务主体，比如tmall、淘宝和零售通就是三个不同的业务。</li>
<li><strong>用例（Use Case）</strong>：描述了用户和系统之间的互动，每个用例提供了一个或多个场景。比如，支付订单就是一个典型的用例。</li>
<li><strong>场景（Scenario）</strong>：场景也被称为用例的实例（Instance），包括用例所有的可能情况（正常的和异常的）。比如对于“订单支付”这个用例，就有“可以使用花呗”，“支付宝余额不足”，“银行账户余额不足”等多个场景。</li>
</ul>
<p>简单来说，就是一个业务是有多个用例组成的，一个用例是有多个场景组成的。用淘宝做一个简单示例，业务、用例和场景的关系如下：<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-5.png" alt="image.png"></p>
<h2 id="新扩展点的实现"><a href="#新扩展点的实现" class="headerlink" title="新扩展点的实现"></a>新扩展点的实现</h2><p>在COLA 2.0中，<a target="_blank" rel="noopener" href="https://blog.csdn.net/significantfrank/article/details/85785565">扩展的实现机制</a>没有变化，主要变化就在于上文中引入的新概念。因为COLA 1.0的扩展设计思想来自于星环，所以当初的扩展粒度也是copy了星环的“业务身份”。COLA 1.0的扩展定位的方法如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-6.png" alt="image.png"></p>
<p>然而，在实际工作中，能像星环那样支撑多个业务的场景并不常见。更多是对不用用例，或是对同一个用例不同场景的差异化支持。比如“创建商品”和“更新商品”是两个用例，但是大部分的业务代码是可以复用的，只有一小部分需要差异化处理。</p>
<p>为了支持这种更细粒度的扩展支持，除了之前的“业务身份（BizId）”之外，我还引入了Use Case和Scenario这两个概念。新的扩展定位如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-7.png"></p>
<p>可以看到，在新的扩展框架下，原来只能支持到“业务身份”的扩展，现在可以支持到“业务身份”，“用例”，“场景”的三级扩展，无疑比以前要灵活的多，并且在表达和可理解性上也比以前好。</p>
<p>在新的扩展框架下，例如我们实现上图中所展示的扩展：在tmall这个业务下——的下单用例——的88VIP场景——的用户身份校验进行扩展，我们只需要声明一个如下的扩展实现（Extension）就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Extension(bizId = &quot;tmall&quot;, useCase = &quot;placeOrder&quot;, scenario = &quot;88vip&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentityCheck88VipExt</span> <span class="keyword">implements</span> <span class="title class_">IdentityCheckExtPt</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h1 id="新二方库定位"><a href="#新二方库定位" class="headerlink" title="新二方库定位"></a>新二方库定位</h1><p>关于二方库的定位表面上来看，是一个简单问题，<strong>因为服务的二方库无外乎就是用来暴露接口和传递数据的（DTO）。不过，往深层次思考，它并不是一个简单的问题，因为它涉及到不同界限上下文（Bounded Context）之间的协作问题。</strong> 它是分布式环境下，不同服务（SOA，RPC，微服务，叫法不同，本质一样）之间如何协作的重要架构设计问题。</p>
<h2 id="Bounded-Context之间的协作"><a href="#Bounded-Context之间的协作" class="headerlink" title="Bounded Context之间的协作"></a>Bounded Context之间的协作</h2><p>如何实现不同域之间的协作，同时又要保证各自领域的概念的完整性是有一套方法论的。总体来说，大概有两种方式：共享内核（Shared Kernel）和防腐层（ACL，Anti-Corruption Layer）。</p>
<p><strong>1. 共享内核（Shared Kernel）</strong></p>
<blockquote>
<p>It’s possible that only one of the teams will maintain the code, build, and test for what is shared. A Shared Kernel is often very difficult to conceive in the first place, and difficult to maintain, because you must have open communication between teams and constant agreement on what constitutes the model to be shared.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-8.png" alt="image.png"></p>
<p>上面是引用《DDD Distilled》（作者是Vaughn Vernon）关于Shared Kernel描述的原话，其优点是Share（减少重复建设），其缺点也是Share（团队之间紧耦合）。</p>
<p><strong>2. 防腐层（ACL，Anti-Corruption Layer）</strong></p>
<blockquote>
<p>An Anticorruption Layer is the most defensive Context Mapping relationship, where the downstream team creates a translation layer between its Ubiquitous Language (model) and the Ubiquitous Language (model) that is upstream to it.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-9.png" alt="image.png"></p>
<p>同样是来自于《DDD Distilled》, 防腐层是隔离最彻底的做法，其优点是没有Share（完全解耦，各自独立），其缺点也是没有Share（有一定的转换成本）。</p>
<p><strong>不过我和Vernon的观点差不多，都比较赞成防腐层的做法。因为增加的语义转换陈本，相较于系统的可维护性和可理解性而言，是完全值得的。</strong></p>
<blockquote>
<p>Whenever possible, you should try to create an Anticorruption Layer between your downstream model and an upstream integration model, so that you can produce model concepts on your side of the integration that specifically fit your business needs and that keep you completely isolated from foreign concepts.</p>
</blockquote>
<h2 id="二方库的重新定位"><a href="#二方库的重新定位" class="headerlink" title="二方库的重新定位"></a>二方库的重新定位</h2><p>在大部分情况下，二方库的确是用来定义服务接口和数据协议的。<strong>但是二方库区别于JSON的地方是它不仅仅是协议，它还是一个Java对象，一个Jar包</strong>。</p>
<p>既然是Java对象，就意味着我们就有可能让DTO承载除了getter，setter之外的更多职能。这个问题以前没有引起我的重视，但是最近在思考domain model的时候，我发现，我们是可以在让二方库承担更多职责的，发挥更大的作用。</p>
<p>实际上，在阿里，我发现有些团队已经在这么实践了，而且我觉得效果还不错。比如，中台的类目二方库，在这个事情上就做了比较好的示范。类目是商品中比较复杂的逻辑，里面涉及很多计算，我们先看一下类目二方库的代码是怎么写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultStdCategoryDO</span> <span class="keyword">implements</span> <span class="title class_">StdCategoryDO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> categoryId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> DefaultStdCategoryDO parent;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;StdCategoryDO&gt; children ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.parent == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getChildren().isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;? <span class="keyword">extends</span> <span class="title class_">StdCategoryDO</span>&gt; getChildren() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.children;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCategoryNamePath</span><span class="params">(String sep)</span> &#123;</span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">DefaultStdCategoryDO</span>&gt; m = <span class="built_in">this</span>.getPathList();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (DefaultStdCategoryDO c : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(sep);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(c.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码，<strong>我们可以发现这已经远远超出DTO的范畴了，这就是一个Domain Model（有数据，有行为，有继承）</strong>。这样做合适吗？我认为是合适的：</p>
<ul>
<li>首先，DefaultStdCategoryDO用到的所有数据都是自恰的，即这些计算是不需要借助外面的辅助，自己就能完成。比如判断是否是根类目，是否是叶子类目，获取类目的名称路径等，都是<strong>依靠自己就能完成</strong>。</li>
<li>其次，这就是一种共享内核，我把自己领域的知识（语言、数据和行为）通过二方库暴露出去了，假如有100个应用需要使用isRoot( )做判断，你们都不需要自己实现了。</li>
</ul>
<p>什么？不是说不推荐共享内核的做法吗？（好吧，小孩子才分对错，好吗）。此处的共享内核我认为是有积极意义的，<strong>特别是类目这种轻数据、重计算的场景</strong>。不过，共享带来的紧耦合也的确是一个问题。所以如果我是类目服务的Consumer的话，我会选择用一个Wrapper去对Category进行包装复用，这样既可以复用它的领域能力，又可以起到隔离防腐的作用。</p>
<h2 id="COLA中的二方库"><a href="#COLA中的二方库" class="headerlink" title="COLA中的二方库"></a>COLA中的二方库</h2><p>说到这里，我想你应该已经理解我对二方库的态度了。是的，二方库不应该仅仅是接口和DTO，而是领域的重要组成部分，是实现Shared Kernel的重要手段。</p>
<p>因此，我打算在COLA 2.0中扩大二方库的职责范围。主要包括两点：</p>
<ol>
<li>二方库中的domain model也是领域的重要组成部分，是“轻量级”的领域能力表达，所谓“轻量级”是说表达是自恰和足够内聚的，类似于上面说的StdCategoryDO的案例。当然，能力的表达也需要遵循通用语言（Ubiquitous Language）。</li>
<li>不同Bounded Context之间的协作，要充分利用好二方库的桥梁作用。其协作方式如下图所示。<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-10.png" alt="image.png"></li>
</ol>
<p><strong>注意，这只是建议，不是标准。实际上，我们永远要在共享和耦合之间做一个权衡，世界上没有完美的架构，也没有完美的设计。</strong> 合不合适，还需要你自己根据实际场景自己去定夺。</p>
<h1 id="COLA框架的扩展机制（彩蛋）"><a href="#COLA框架的扩展机制（彩蛋）" class="headerlink" title="COLA框架的扩展机制（彩蛋）"></a>COLA框架的扩展机制（彩蛋）</h1><p>至此，关于COLA 2.0的改动点我已经交代的差不多了。再追加一个彩蛋吧。泄密一下COLA作为一个框架（Framework）是如何支持扩展的。</p>
<p>框架作为一个组件是被集成在系统中完成某一特定任务的，比如logback作为一个日志框架是帮助我们解决打印日志、日志格式、日志存储等问题的。但面对各种应用场景，框架本身没办法预测你想要的日志格式、日志归档的方式。这些地方需要一个扩展机制，赋能用户自己去配置、去扩展。</p>
<p>就扩展的实现方式而言，一般有两种方式，一种是基于接口的扩展，一种是基于数据配置的扩展。</p>
<h2 id="基于接口的扩展"><a href="#基于接口的扩展" class="headerlink" title="基于接口的扩展"></a>基于接口的扩展</h2><p>基于接口的扩展，主要是利用面向对象的多态机制，<strong>先在框架中定义一个接口（或者抽象方法）和处理该接口的模板，然后用户实现自己的定制。</strong> 其原理如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-11.png" alt="image.png"></p>
<p>这种扩展方式在框架中使用很广泛，例如Spring中的<code>ApplicationListener</code>，用户可以实现这个Listener来做容器初始化之后的特殊处理。再比如logback中的<code>AppenderBase</code>，用户可以通过继承<code>AppenderBase</code>实现定制的Appender诉求（往消息队列发送日志）。</p>
<p>COLA作为一个框架，这样的扩展能力在所难免，比如，我们有一个<code>ExceptionHandlerI</code>，在框架中我们提供了一个默认实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">ExceptionHandlerI</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DefaultExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">DefaultExceptionHandler</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultExceptionHandler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleException</span><span class="params">(Command cmd, Response response, Exception exception)</span> &#123;</span><br><span class="line">        buildResponse(response, exception);</span><br><span class="line">        printLog(cmd, response, exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLog</span><span class="params">(Command cmd, Response response, Exception exception)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> BaseException)&#123;</span><br><span class="line">            <span class="comment">//biz exception is expected, only warn it</span></span><br><span class="line">            logger.warn(buildErrorMsg(cmd, response));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//sys exception should be monitored, and pay attention to it</span></span><br><span class="line">            logger.error(buildErrorMsg(cmd, response), exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，并不是每个应用都愿意这样的安排，因此我们提供了扩展，当用户提供了自己<code>ExceptionHandlerI</code>实现的时候，优先使用用户的实现，如果用户没有提供，使用默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlerFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExceptionHandlerI <span class="title function_">getExceptionHandler</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ApplicationContextHelper.getBean(ExceptionHandlerI.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex)&#123;</span><br><span class="line">            <span class="keyword">return</span> DefaultExceptionHandler.singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于数据配置的扩展"><a href="#基于数据配置的扩展" class="headerlink" title="基于数据配置的扩展"></a>基于数据配置的扩展</h2><p>基于配置数据的扩展，首先要约定一个数据格式，然后通过利用用户提供的数据，组装成实例对象，用户提供的数据是对象中的属性（有时候也可能是类，比如slfj中的StaticLoggerBinder），其原理如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-12.png" alt="image.png"></p>
<p>我们一般在应用中使用的KV配置都属于这种形式，框架中的使用场景也很多，比如上面提到的logback中对日志格式、日志大小的logback.xml配置。</p>
<p>在COLA中，我们通过Annotation对扩展点的配置<code>@Extension(bizId = &quot;tmall&quot;, useCase = &quot;placeOrder&quot;, scenario = &quot;88vip&quot;)</code>，也是一种典型的基于数据的配置扩展。</p>
<h1 id="如何使用COLA-2-0"><a href="#如何使用COLA-2-0" class="headerlink" title="如何使用COLA 2.0"></a>如何使用COLA 2.0</h1><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>COLA 2.0的源代码在：<a target="_blank" rel="noopener" href="https://github.com/alibaba/COLA/">https://github.com/alibaba/COLA/</a></p>
<h2 id="生成COLA应用"><a href="#生成COLA应用" class="headerlink" title="生成COLA应用"></a>生成COLA应用</h2><p>COLA 2.0 提供了两套Archetype，一套是纯后端应用，另一套是Web后端应用，他们的区别是Web后端应用比纯后端应用多了一个Controller模块，其它都一样。Archetype的二方库我已经上传到Maven Repo了，可以通过如下命令生成COLA应用：</p>
<ol>
<li><strong>生成纯后端应用（没有Controller）</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate  -DgroupId=com.alibaba.demo -DartifactId=demo -Dversion=1.0.0-SNAPSHOT -Dpackage=com.alibaba.demo -DarchetypeArtifactId=cola-framework-archetype-service -DarchetypeGroupId=com.alibaba.cola -DarchetypeVersion=2.0.1</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>生成Web后端应用（有Controller）</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate  -DgroupId=com.alibaba.demo -DartifactId=demo -Dversion=1.0.0-SNAPSHOT -Dpackage=com.alibaba.demo -DarchetypeArtifactId=cola-framework-archetype-web -DarchetypeGroupId=com.alibaba.cola -DarchetypeVersion=2.0.1</span><br></pre></td></tr></table></figure>

<p>我们假设新建的应用叫demo，那么执行命令后，会看到如下的模块结构，上部分是应用骨架，下部分是COLA框架。<br><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-13.png" alt="image.png"></p>
<p>在生成的应用里面有一些demo的代码，可以直接用&quot;mvn test&quot;进行测试。如果是Web后端应用，可以运行<code>TestApplication</code>启动Spring Boot容器，然后直接通过REST URL <a target="_blank" rel="noopener" href="http://localhost:8080/customer?name=Alibaba">http://localhost:8080/customer?name=Alibaba</a> 访问服务。</p>
<h1 id="COLA-2-0整体架构"><a href="#COLA-2-0整体架构" class="headerlink" title="COLA 2.0整体架构"></a>COLA 2.0整体架构</h1><p>最后，按照老规矩，还是给两张全局的架构视图。以便你可以从全局上把握COLA。</p>
<p><strong>注意：COLA有两层含义，一层含义是作为框架的COLA，主要提供一些应用中所需共用组件的支持。另一层含义是指COLA架构，是指通过COLA Archetype生成的应用骨架的架构。这里所说的架构视图是应用架构视图。</strong></p>
<h2 id="依赖视图"><a href="#依赖视图" class="headerlink" title="依赖视图"></a>依赖视图</h2><p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-14.png" alt="image.png"></p>
<h2 id="调用视图"><a href="#调用视图" class="headerlink" title="调用视图"></a>调用视图</h2><p><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/blog/architecture/cola2.0-15.png" alt="image.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wangyyovo.github.io">Blank</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wangyyovo.github.io/posts/76fc8d15/">https://wangyyovo.github.io/posts/76fc8d15/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wangyyovo.github.io" target="_blank">Blank</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/architecture/">architecture</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/2b1dba393544c73910d963c2fac19f85.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/d1f4d279/" title="Golang使用validator进行数据校验及自定义翻译器"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/golang/376d00bf7cc51c2d800596886b79e2fe.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang使用validator进行数据校验及自定义翻译器</div></div><div class="info-2"><div class="info-item-1"> Golang使用validator进行数据校验及自定义翻译器 包下载：go get github.com&#x2F;go-playground&#x2F;validator&#x2F;v10 https://pkg.go.dev/github.com/go-playground/validator/v10#pkg-overview  一、概述在接口开发经常会遇到一个问题是后端需要写大量的繁琐代码进行数据校验，所以就想着有没有像前端校验一样写规则进行匹配校验，然后就发现了validator包，一个比较强大的校验工具包下面是一些学习总结，详细内容可以查看validator 二、操作符说明   标记 标记说明    , 多操作符分割   | 或操作   - 跳过字段验证   三、常用标记说明比较运算符    运算符 运算描述 例子    eq 等于 Field validate:&quot;eq=0&quot;   gt 大于 Field validate:&quot;gt=0&quot;   gte 大于等于 Field validate:&quot;gte=0&quot;   l...</div></div></div></a><a class="pagination-related" href="/posts/de3957af/" title="DDNS"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/vpn/079255e4ae023c2a57f1a82fdc28aa67.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">DDNS</div></div><div class="info-2"><div class="info-item-1"> DDNS ddns  脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/bin/bash# 根据实际修改以下字段值auth_email=&quot;user@example.com&quot;    # CloudFlare 注册邮箱auth_key=&quot;c2547eb745079dac9320b638f5e225cf483cc5cfdda41&quot;   # API Keyzone_name=&quot;example.com&quot;   # 要做指向的根域名record_name=&quot;www.example.com&quot;   # 要做指向的记录# 根据需要修改ip=$(curl -s http://ipv4.icanhazip.com)   # 获取外网 IPip_file=&quot;ip.txt&quot;  # IP 自动检测记录id_file=&quot;cloudflare....</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/209eb15b/" title="领域驱动设计"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/31ce17fbd9dc0ee80bbe035015d399dd.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-25</div><div class="info-item-2">领域驱动设计</div></div><div class="info-2"><div class="info-item-1"> 应用层  聚合 聚合根 值对象 实体 领域模型 领域&#x2F;子域 领域事件 领域服务 事件回溯 基础设施 工厂 仓库 上下文 CQRS  dci https://www.cnblogs.com/Leo_wl/p/3866629.html#_label0 https://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html https://blog.csdn.net/kkkkkxiaofei/article/details/62237121 https://www.jianshu.com/c/fe7dd7fc5372 聚合（根）、实体、值对象总结1. 聚合根、实体、值对象的区别？从标识的角度： 聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识，不存在这个值对象或那个值对象的说法； 从是否只读的角度： 聚合根除了唯一标识外，其他所有状态信息都理论上可变；实体是可变的；值对象是只读的； 从生命周期的角度： 聚合根有独立的生命周期，实体的生命周期从属于其所属的聚合，实体完全由其所属的聚合根...</div></div></div></a><a class="pagination-related" href="/posts/19d3b997/" title="CQRS模式"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/16ab95126bb92ad479a36b0e70a0cc69.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-25</div><div class="info-item-2">CQRS模式</div></div><div class="info-2"><div class="info-item-1">  http://www.cqrs.nu/ https://www.cnblogs.com/yangecnu/p/Introduction-CQRS.html  CQRS模式在常用的三层架构中，通常都是通过数据访问层来修改或者查询数据，一般修改和查询使用的是相同的实体。在一些业务逻辑简单的系统中可能没有什么问题，但是随着系统逻辑变得复杂，用户增多，这种设计就会出现一些性能问题。虽然在DB上可以做一些读写分离的设计，但在业务上如果在读写方面混合在一起的话，仍然会出现一些问题。 本文介绍了命令查询职责分离模式(Command Query Responsibility  Segregation，CQRS)，该模式从业务上分离修改  (Command，增，删，改，会对系统状态进行修改)和查询（Query，查，不会对系统状态进行修改)的行为。从而使得逻辑更加清晰，便于对不同部分进行针对性的优化。文章首先简要介绍了传统的CRUD方式存在的问题，接着介绍了CQRS模式，最后以一个简单的在线日记系统演示了如何实现CQRS模式。要谈到读写操作，首先我们来看传统的CRUD的问题。 一. CRUD方式...</div></div></div></a><a class="pagination-related" href="/posts/2dbc8f16/" title="DCI架构"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/adde6bf5e9380e7166faad612f669036.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-25</div><div class="info-item-2">DCI架构</div></div><div class="info-2"><div class="info-item-1">  https://www.artima.com/articles/dci_vision.html https://www.jdon.com/37976  The DCI Architecture: A New Vision of Object-Oriented Programmingby Trygve Reenskaug and James O. CoplienMarch 20, 2009  ​    Summary​    Object-oriented programming was supposed to unify the    perspectives of the programmer and the end user in computer    code: a boon both to usability and program comprehension. While    objects capture structure well, they fail to capture system    action. DCI is a vision to capt...</div></div></div></a><a class="pagination-related" href="/posts/59aefec5/" title="六边形架构"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/24169e4e588622ff1207521678c89699.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-25</div><div class="info-item-2">六边形架构</div></div><div class="info-2"><div class="info-item-1">  https://www.jianshu.com/p/c2a361c2406c  六边形架构六边形架构又称“端口和适配器模式”，是Alistair Cockburn提出的一种具有对称性特征的架构风格。在这种架构中，系统通过适配器的方式与外部交互，将应用服务于领域服务封装在系统内部。   六边形架构还是一种分层架构，如上图所示，它被分为了三层：端口适配器、应用层与领域层。而端口又可以分为输入端口和输出端口。  输入端口 用于系统提供服务时暴露API接口，接受外部客户系统的输入，并客户系统的输入转化为程序内部所能理解的输入。系统作为服务提供者是对外的接入层可以看成是输入端口。 输出端口 为系统获取外部服务提供支持，如获取持久化状态、对结果进行持久化，或者发布领域状态的变更通知（如领域事件）。系统作为服务的消费者获取服务是对外的接口（数据库、缓存、消息队列、RPC调用）等都可以看成是输入端口。 应用层 定义系统可以完成的工作，很薄的一层。它并不处理业务逻辑通过协调领域对象或领域服务完成业务逻辑，并通过输入端口输出结果。也可以在这一层进行事物管理。 领域层 负责表示业务概念、规则与状态...</div></div></div></a><a class="pagination-related" href="/posts/80459d/" title="Clean架构"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/c4bfdae0870cf61b60206d8521077d02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-25</div><div class="info-item-2">Clean架构</div></div><div class="info-2"><div class="info-item-1"> Clean架构 外圈的层次可以依赖内层，反之不可以；内圈核心的实体代表业务，不可以依赖其所处的技术环境。 这是著名软件大师Bob大叔提出的一种架构，也是当前各种语言开发架构。干净架构提出了一种单向依赖关系，从而在逻辑上形成一种向上的抽象系统。 这种干净的架构图如下： ​     依赖规则Dependency Rule上图中同心圆代表各种不同领域的软件。一般来说，越深入代表你的软件层次越高。外圆是战术实现机制，内圆的是战略核心策略。 使此体系架构能够工作的关键是依赖规则。这条规则规定源代码只能向内依赖，在最里面的部分对外面一点都不知道，也就是内部不依赖外部，而外部依赖内部。这种依赖包含代码名称、类的函数、变量或任何其他命名软件实体。 同样，在外面圈中使用的数据格式不应被内圈中使用，特别是如果这些数据格式是由外面一圈的框架生成的。我们不希望任何外圆的东西会影响内圈层。 实体Entities实体封装的是企业业务规则，一个实体是一个带有方法的对象，或者是一系列数据结构和函数，只要这个实体能够被不同的应用程序使用即可。 如果你没有编写企业软件，只是编写简单的应用程序，这些实体就是应用的业...</div></div></div></a><a class="pagination-related" href="/posts/fcc4b93a/" title="常见的五种软件架构"><img class="cover" src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/architecture/30c79bc2b36136d52bd197a8c0752131.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-25</div><div class="info-item-2">常见的五种软件架构</div></div><div class="info-2"><div class="info-item-1">  http://www.ruanyifeng.com/blog/2016/09/software-architecture.html  常见的五种软件架构软件架构（software architecture）就是软件的基本结构。 合适的架构是软件成功的最重要因素之一。大型软件公司通常有专门的架构师职位（architect），只有资深程序员才可以担任。 O&#39;Reilly 出版过一本免费的小册子《Software Architecture Patterns》（PDF）， 介绍了五种最常见的软件架构，是非常好的入门读物。我读后受益匪浅，下面就是我的笔记。 一、分层架构分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。如果你不知道要用什么架构，那就用它。 这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。 虽然没有明确约定，软件一定要分成多少层，但是四层的结构最常见。    表现层（presentation）：用户界面，负责视觉和用户互动 业务层（business）：实现业务逻...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Blank</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">352</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>主题 GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">新架构分层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E7%BB%84%E4%BB%B6%E5%88%92%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">新组件划分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%92%8C%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">模块和组件的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#COLA-2-0%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">COLA 2.0的组件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E6%89%A9%E5%B1%95%E7%82%B9%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">新扩展点设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E6%96%B0%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">引入新概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E6%89%A9%E5%B1%95%E7%82%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">新扩展点的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E4%BA%8C%E6%96%B9%E5%BA%93%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.</span> <span class="toc-text">新二方库定位</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bounded-Context%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">Bounded Context之间的协作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E6%96%B9%E5%BA%93%E7%9A%84%E9%87%8D%E6%96%B0%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.2.</span> <span class="toc-text">二方库的重新定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#COLA%E4%B8%AD%E7%9A%84%E4%BA%8C%E6%96%B9%E5%BA%93"><span class="toc-number">4.3.</span> <span class="toc-text">COLA中的二方库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#COLA%E6%A1%86%E6%9E%B6%E7%9A%84%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%EF%BC%88%E5%BD%A9%E8%9B%8B%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">COLA框架的扩展机制（彩蛋）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">5.1.</span> <span class="toc-text">基于接口的扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">5.2.</span> <span class="toc-text">基于数据配置的扩展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8COLA-2-0"><span class="toc-number">6.</span> <span class="toc-text">如何使用COLA 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">6.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90COLA%E5%BA%94%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">生成COLA应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#COLA-2-0%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">COLA 2.0整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E8%A7%86%E5%9B%BE"><span class="toc-number">7.1.</span> <span class="toc-text">依赖视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="toc-number">7.2.</span> <span class="toc-text">调用视图</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d14168d/" title="虚拟机问题合集"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/hexo/090cfe4e9e60b0ad0de05db822f3ae97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="虚拟机问题合集"/></a><div class="content"><a class="title" href="/posts/d14168d/" title="虚拟机问题合集">虚拟机问题合集</a><time datetime="2022-07-16T13:30:36.000Z" title="发表于 2022-07-16 21:30:36">2022-07-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f540045f/" title="用go语言编写移动端sdk和app开发"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/golang/941ed1ec2925719a0c92e76f4f786b6a.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用go语言编写移动端sdk和app开发"/></a><div class="content"><a class="title" href="/posts/f540045f/" title="用go语言编写移动端sdk和app开发">用go语言编写移动端sdk和app开发</a><time datetime="2022-07-04T12:14:21.000Z" title="发表于 2022-07-04 20:14:21">2022-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5faac006/" title="在线编程IDE"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/hexo/090cfe4e9e60b0ad0de05db822f3ae97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在线编程IDE"/></a><div class="content"><a class="title" href="/posts/5faac006/" title="在线编程IDE">在线编程IDE</a><time datetime="2022-06-12T13:30:36.000Z" title="发表于 2022-06-12 21:30:36">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7594185d/" title="即时性能分析工具Pyroscope"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/golang/3bfb3279740bc9a5b5ef436fa887ef07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="即时性能分析工具Pyroscope"/></a><div class="content"><a class="title" href="/posts/7594185d/" title="即时性能分析工具Pyroscope">即时性能分析工具Pyroscope</a><time datetime="2022-06-12T08:07:36.000Z" title="发表于 2022-06-12 16:07:36">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/82a7aa7c/" title="golang性能调试优化方法"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/cover/common/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="golang性能调试优化方法"/></a><div class="content"><a class="title" href="/posts/82a7aa7c/" title="golang性能调试优化方法">golang性能调试优化方法</a><time datetime="2022-06-12T03:00:36.000Z" title="发表于 2022-06-12 11:00:36">2022-06-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Blank</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 5.4.2</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"placeholder":"请留下你的脚印","pageSize":10,"lang":"zh-CN"}

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'BSfgwCPLOvPHVPaSoBCGSENf-MdYXbMMI',
      appKey: '2Q8qq5060qxycL6FPL26LnMG',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>