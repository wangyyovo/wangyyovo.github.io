<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Protobuf语言指南(proto3) | Blank</title><meta name="author" content="Blank"><meta name="copyright" content="Blank"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Protobuf 语言指南(proto 3)这个指南描述了如何使用Protocol buffer 语言去描述你的protocol buffer 数据， 包括 .proto文件符号和如何从.proto文件生成类。 这是一个参考指南——对于使用本文档中描述的许多功能的分步示例。 定义一个消息类型先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的">
<meta property="og:type" content="article">
<meta property="og:title" content="Protobuf语言指南(proto3)">
<meta property="og:url" content="https://wangyyovo.github.io/posts/2658c59b/">
<meta property="og:site_name" content="Blank">
<meta property="og:description" content="Protobuf 语言指南(proto 3)这个指南描述了如何使用Protocol buffer 语言去描述你的protocol buffer 数据， 包括 .proto文件符号和如何从.proto文件生成类。 这是一个参考指南——对于使用本文档中描述的许多功能的分步示例。 定义一个消息类型先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/protobuf/f0c430a4a8138df369038db54a3b8af2.jpg">
<meta property="article:published_time" content="2019-09-27T08:30:36.000Z">
<meta property="article:modified_time" content="2019-09-27T08:30:36.000Z">
<meta property="article:author" content="Blank">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/protobuf/f0c430a4a8138df369038db54a3b8af2.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Protobuf语言指南(proto3)",
  "url": "https://wangyyovo.github.io/posts/2658c59b/",
  "image": "https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/protobuf/f0c430a4a8138df369038db54a3b8af2.jpg",
  "datePublished": "2019-09-27T08:30:36.000Z",
  "dateModified": "2019-09-27T08:30:36.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Blank",
      "url": "https://wangyyovo.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/favicon.ico"><link rel="canonical" href="https://wangyyovo.github.io/posts/2658c59b/"><link rel="preconnect" href="https://jsd.012700.xyz"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://jsd.012700.xyz/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Blank","link":"链接: ","source":"来源: Blank","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://jsd.012700.xyz/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Protobuf语言指南(proto3)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="alternate" href="/atom.xml" title="Blank" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">352</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 教程</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/21cfbf15/"><span> 🚀 快速開始</span></a></li><li><a class="site-page child" href="/posts/dc584b87/"><span> 📑 主題頁面</span></a></li><li><a class="site-page child" href="/posts/4aa8abbe/"><span> 🛠 主題配置</span></a></li><li><a class="site-page child" href="/posts/ceeb73f/"><span> ⚔️ 標簽外挂</span></a></li><li><a class="site-page child" href="/posts/98d20436/"><span> ❓ 主題問答</span></a></li><li><a class="site-page child" href="/posts/4073eda/"><span> ⚡️ 進階教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/protobuf/f0c430a4a8138df369038db54a3b8af2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Blank</span></a><a class="nav-page-title" href="/"><span class="site-name">Protobuf语言指南(proto3)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 教程</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/posts/21cfbf15/"><span> 🚀 快速開始</span></a></li><li><a class="site-page child" href="/posts/dc584b87/"><span> 📑 主題頁面</span></a></li><li><a class="site-page child" href="/posts/4aa8abbe/"><span> 🛠 主題配置</span></a></li><li><a class="site-page child" href="/posts/ceeb73f/"><span> ⚔️ 標簽外挂</span></a></li><li><a class="site-page child" href="/posts/98d20436/"><span> ❓ 主題問答</span></a></li><li><a class="site-page child" href="/posts/4073eda/"><span> ⚡️ 進階教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Protobuf语言指南(proto3)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-09-27T08:30:36.000Z" title="发表于 2019-09-27 16:30:36">2019-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-09-27T08:30:36.000Z" title="更新于 2019-09-27 16:30:36">2019-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/protobuf/">protobuf</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/2658c59b/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/2658c59b/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><script src="\assets\js\APlayer.min.js"> </script><h1 id="Protobuf-语言指南-proto-3"><a href="#Protobuf-语言指南-proto-3" class="headerlink" title="Protobuf 语言指南(proto 3)"></a>Protobuf 语言指南(proto 3)</h1><p>这个指南描述了如何使用Protocol buffer 语言去描述你的protocol buffer 数据， 包括 <code>.proto</code>文件符号和如何从.proto文件生成类。</p>
<p>这是一个参考指南——对于使用本文档中描述的许多功能的分步示例。</p>
<h2 id="定义一个消息类型"><a href="#定义一个消息类型" class="headerlink" title="定义一个消息类型"></a>定义一个消息类型</h2><p>先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件的第一行指定了你正在使用<code>proto3</code>语法：如果你没有指定这个，编译器会使用<code>proto2</code>。这个指定语法行必须是文件的非空非注释的第一个行。</li>
<li><code>SearchRequest</code>消息格式有3个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。</li>
</ul>
<h3 id="指定字段类型"><a href="#指定字段类型" class="headerlink" title="指定字段类型"></a>指定字段类型</h3><p>在上面的例子中，所有字段都是标量类型：两个整型（<code>page_number</code>和<code>result_per_page</code>），一个string类型（<code>query</code>）。当然，你也可以为字段指定其他的合成类型，包括枚举（<code>enumerations</code>）或其他消息类型。</p>
<h3 id="分配标识号"><a href="#分配标识号" class="headerlink" title="分配标识号"></a>分配标识号</h3><p>正如你所见，在消息定义中，每个字段都有<code>唯一</code>的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p>
<p>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的19000－19999( 从<code>FieldDescriptor::kFirstReservedNumber</code>到 <code>FieldDescriptor::kLastReservedNumber</code>)的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期<code>reserved</code>标识号。</p>
<h3 id="指定字段规则"><a href="#指定字段规则" class="headerlink" title="指定字段规则"></a>指定字段规则</h3><p>所指定的消息字段修饰符必须是如下之一：</p>
<ul>
<li>singular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。</li>
<li>repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。</li>
</ul>
<p>在proto3中，<code>repeated</code>的标量域默认情况下使用<code>packed</code>。</p>
<p>你可以了解更多的<code>pakced</code>属性在Protocol Buffer 编码</p>
<h3 id="添加更多消息类型"><a href="#添加更多消息类型" class="headerlink" title="添加更多消息类型"></a>添加更多消息类型</h3><p>在一个.proto文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用,例如，如果想定义与SearchResponse消息类型对应的回复消息格式的话，你可以将它添加到相同的.proto文件中，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><p>向.proto文件添加注释，可以使用C&#x2F;C++风格（<code>//和</code> <code>/* ... */</code> ） 语法，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SearchRequest represents a search query, with pagination options to</span></span><br><span class="line"><span class="comment"> * indicate which results to include in the response. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;  <span class="comment">// Which page number do we want?</span></span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;  <span class="comment">// Number of results to return per page.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从-proto文件生成了什么？"><a href="#从-proto文件生成了什么？" class="headerlink" title="从.proto文件生成了什么？"></a>从.proto文件生成了什么？</h3><p>当用protocol buffer编译器来运行<code>.proto</code>文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>
<ul>
<li><p>对<code>C++</code>来说，编译器会为每个.proto文件生成一个<code>.h</code>文件和一个<code>.cc</code>文件，.proto文件中的每一个消息有一个对应的类。</p>
</li>
<li><p>对<code>Java</code>来说，编译器为每一个消息类型生成了一个<code>.java</code>文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。</p>
</li>
<li><p>对<code>Python</code>来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。</p>
</li>
<li><p>对<code>go</code>来说，编译器会位每个消息类型生成了一个<code>.pd.go</code>文件。</p>
</li>
<li><p>对于<code>Ruby</code>来说，编译器会为每个消息类型生成了一个<code>.rb</code>文件。</p>
</li>
<li><p>对于Objective-C来说，编译器会为每个消息类型生成了一个<code>pbobjc.h</code>文件和pbobjcm文件，.proto文件中的每一个消息有一个对应的类。</p>
</li>
<li><p>对于C#来说，编译器会为每个消息类型生成了一个<code>.cs</code>文件，<code>.proto</code>文件中的每一个消息有一个对应的类。</p>
</li>
</ul>
<p>你可以从如下的文档链接中获取每种语言更多API(proto3版本的内容很快就公布)。<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/reference/overview">API Reference</a></p>
<h2 id="标量数值类型"><a href="#标量数值类型" class="headerlink" title="标量数值类型"></a>标量数值类型</h2><p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>C++ Type</th>
<th>Java Type</th>
<th>Go Type</th>
<th>Ruby Type</th>
<th>C# Type</th>
<th>Python Type[2]</th>
<th>PHP Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float64</td>
<td>Float</td>
<td>double</td>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>Float</td>
<td>float</td>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>int32</td>
<td>使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代</td>
<td>int32</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>uint32</td>
<td>使用变长编码</td>
<td>uint32</td>
<td>int</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要</td>
<td>uint</td>
<td>int&#x2F;long</td>
<td>integer</td>
</tr>
<tr>
<td>uint64</td>
<td>使用变长编码</td>
<td>uint64</td>
<td>long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>int&#x2F;long</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>sint32</td>
<td>使用变长编码，这些编码在负值时比int32高效的多</td>
<td>int32</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要</td>
<td>int</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>sint64</td>
<td>使用变长编码，有符号的整型值。编码时比通常的int64高效。</td>
<td>int64</td>
<td>long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>int&#x2F;long</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。</td>
<td>uint32</td>
<td>int</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要</td>
<td>uint</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。</td>
<td>uint64</td>
<td>long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>int&#x2F;long</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>sfixed32</td>
<td>总是4个字节</td>
<td>int32</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要</td>
<td>int</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>sfixed64</td>
<td>总是8个字节</td>
<td>int64</td>
<td>long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>int&#x2F;long</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>TrueClass&#x2F;FalseClass</td>
<td>bool</td>
<td>bool</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td>
<td>string</td>
<td>String</td>
<td>string</td>
<td>String (UTF-8)</td>
<td>string</td>
<td>str&#x2F;unicode</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>可能包含任意顺序的字节数据。</td>
<td>string</td>
<td>ByteString</td>
<td>[]byte</td>
<td>String (ASCII-8BIT)</td>
<td>ByteString</td>
<td>str</td>
<td>string</td>
</tr>
</tbody></table>
<p>你可以在文章<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-cn">Protocol Buffer 编码</a>中，找到更多“序列化消息时各种类型如何编码”的信息。</p>
<ul>
<li><p>在java中，无符号32位和64位整型被表示成他们的整型对应形似，最高位被储存在标志位中。</p>
</li>
<li><p>对于所有的情况，设定值会执行类型检查以确保此值是有效。</p>
</li>
<li><p>64位或者无符号32位整型在解码时被表示成为ilong，但是在设置时可以使用int型值设定，在所有的情况下，值必须符合其设置其类型的要求。</p>
</li>
<li><p>python中string被表示成在解码时表示成unicode。但是一个ASCIIstring可以被表示成str类型。</p>
</li>
<li><p>Integer在64位的机器上使用，string在32位机器上使用</p>
</li>
</ul>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：</p>
<ul>
<li><p>对于strings，默认是一个空string</p>
</li>
<li><p>对于bytes，默认是一个空的bytes</p>
</li>
<li><p>对于bools，默认是false</p>
</li>
<li><p>对于数值类型，默认是0</p>
</li>
<li><p>对于枚举，默认是第一个定义的枚举值，必须为0;</p>
</li>
<li><p>对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见generated code guide</p>
</li>
</ul>
<p>对于可重复域的默认值是空（通常情况下是对应语言中空列表）。</p>
<p>注：对于标量消息域，一旦消息被解析，就无法判断域释放被设置为默认值（例如，例如boolean值是否被设置为false）还是根本没有被设置。你应该在定义你的消息类型时非常注意。例如，比如你不应该定义boolean的默认值false作为任何行为的触发方式。也应该注意如果一个标量消息域被设置为标志位，这个值不应该被序列化传输。</p>
<p>查看<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/reference/overview">generated code guide</a> 选择你的语言的默认值的工作细节。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个<code>SearchRequest</code>消息添加一个 <code>corpus字段</code>，而corpus的值可能是<code>UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO</code>中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（<code>enum</code>）并且为每个可能的值定义一个常量就可以了。</p>
<p>在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型，它含有所有可能的值，以及一个类型为<code>Corpus</code>的字段：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">        UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">        WEB = <span class="number">1</span>;</span><br><span class="line">        IMAGES = <span class="number">2</span>;</span><br><span class="line">        LOCAL = <span class="number">3</span>;</span><br><span class="line">        NEWS = <span class="number">4</span>;</span><br><span class="line">        PRODUCTS = <span class="number">5</span>;</span><br><span class="line">        VIDEO = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Corpus corpus = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，Corpus枚举的第一个常量映射为0：每个枚举类型必须将其第一个类型映射为0，这是因为：</p>
<ul>
<li>必须有有一个0值，我们可以用这个0值作为默认值。</li>
<li>这个零值必须为第一个元素，为了兼容proto2语义，枚举类的第一个值总是默认值。</li>
</ul>
<p>你可以通过将不同的枚举常量指定位相同的值。如果这样做你需要将allow_alias设定位true，否则编译器会在别名的地方产生一个错误信息。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">EnumAllowingAlias</span> &#123;</span><br><span class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum </span><span class="title class_">EnumNotAllowingAlias</span> &#123;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举常量必须在32位整型值的范围内。因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举，这些枚举可以在<code>.proto</code>文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它，采用<code>MessageType.EnumType</code>的语法格式。</p>
<p>当对一个使用了枚举的<code>.proto</code>文件运行protocol buffer编译器的时候，生成的代码中将有一个对应的enum（对Java或C++来说），或者一个特殊的<code>EnumDescriptor</code>类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p>
<p>在反序列化的过程中，无法识别的枚举值会被保存在消息中，虽然这种表示方式需要依据所使用语言而定。在那些支持开放枚举类型超出指定范围之外的语言中（例如C++和Go），为识别的值会被表示成所支持的整型。在使用封闭枚举类型的语言中（Java），使用枚举中的一个类型来表示未识别的值，并且可以使用所支持整型来访问。在其他情况下，如果解析的消息被序列号，未识别的值将保持原样。</p>
<p>关于如何在你的应用程序的消息中使用枚举的更多信息，请查看所选择的语言<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/reference/overview">generated code guide</a> </p>
<h3 id="保留标识符（Reserved）"><a href="#保留标识符（Reserved）" class="headerlink" title="保留标识符（Reserved）"></a>保留标识符（Reserved）</h3><p>如果你通过删除或者注释所有域，以后的用户可以重用标识号当你重新更新类型的时候。如果你使用旧版本加载相同的.proto文件这会导致严重的问题，包括数据损坏、隐私错误等等。现在有一种确保不会发生这种情况的方法就是指定保留标识符（可能导致JSON序列化问题），protocol buffer的编译器会警告未来尝试使用这些域标识符的用户。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>;</span><br><span class="line">  reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：不要在同一行<code>reserved</code>声明中同时声明域名字和标识号</p>
<h2 id="使用其他消息类型"><a href="#使用其他消息类型" class="headerlink" title="使用其他消息类型"></a>使用其他消息类型</h2><p>你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入定义"><a href="#导入定义" class="headerlink" title="导入定义"></a>导入定义</h3><p>在上面的例子中，Result消息类型与<code>SearchResponse</code>是定义在同一文件中的。如果想要使用的消息类型已经在其他<code>.proto</code>文件中已经定义过了呢？<br>你可以通过导入（importing）其他<code>.proto</code>文件中的定义来使用它们。要导入其他<code>.proto</code>文件的定义，你需要在你的文件中添加一个导入声明，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;myproject/other_protos.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个<code>.proto</code>文件到一个新的位置， 可以不直接移动<code>.proto</code>文件， 只需放入一个伪<code> .proto</code> 文件在老的位置， 然后使用<code>import public</code>转向新的位置。<code>import public </code>依赖性会通过任意导入包含<code>import public</code>声明的proto文件传递。例如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是新的proto</span></span><br><span class="line"><span class="comment">// All definitions are moved here</span></span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是久的proto</span></span><br><span class="line"><span class="comment">// 这是所有客户端正在导入的包</span></span><br><span class="line"><span class="keyword">import</span> public <span class="string">&quot;new.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;other.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;old.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 现在你可以使用新久两种包的proto定义了。</span></span><br></pre></td></tr></table></figure>

<p>通过在编译器命令行参数中使用<code>-I/--proto_pathprotocal</code> 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常你只要指定<code>proto_path</code>标志为你的工程根目录就好。并且指定好导入的正确名称就好。</p>
<h3 id="使用proto2消息类型"><a href="#使用proto2消息类型" class="headerlink" title="使用proto2消息类型"></a>使用proto2消息类型</h3><p>在你的proto3消息中导入proto2的消息类型也是可以的，反之亦然，然后proto2枚举不可以直接在proto3的标识符中使用（如果仅仅在proto2消息中使用是可以的）。<br>嵌套类型</p>
<p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在<code>SearchResponse</code>消息内，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">        <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">        <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以<code>Parent.Type</code>的形式使用它，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SomeOtherMessage</span> &#123;</span><br><span class="line">	SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，你也可以将消息嵌套任意多层，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Outer</span> &#123;                  <span class="comment">// Level 0</span></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleAA</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="type">int64</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleBB</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="type">int32</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更新一个消息类型"><a href="#更新一个消息类型" class="headerlink" title="更新一个消息类型"></a>更新一个消息类型</h2><p>如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。</p>
<ul>
<li><p>不要更改任何已有的字段的数值标识。</p>
</li>
<li><p>如果你增加新的字段，使用旧格式的字段仍然可以被你新产生的代码所解析。你应该记住这些元素的默认值这样你的新代码就可以以适当的方式和旧代码产生的数据交互。相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和proto2中的行为是不同的，在proto2中未定义的域依然会随着消息被序列化）</p>
</li>
<li><p>非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</p>
</li>
<li><p>int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。</p>
</li>
<li><p>sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。<br>string和bytes是兼容的——只要bytes是有效的UTF-8编码。<br>嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。<br>fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。</p>
</li>
<li><p>枚举类型与int32，uint32，int64和uint64相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化*之后他们可能会有不同的处理方式，例如，未识别的proto3枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int类型的字段总会保留他们的</p>
</li>
</ul>
<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入<code>import google/protobuf/any.proto</code></p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ErrorStatus</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于给定的消息类型的默认类型URL是<code>type.googleapis.com/packagename.messagename</code>。</p>
<p>不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装Any值。例如在java中，Any类型会有特殊的<code>pack()</code>和<code>unpack()</code>访问器，在C++中会有<code>PackFrom()</code>和<code>UnpackTo()</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Storing an arbitrary message type in Any.</span></span><br><span class="line">NetworkErrorDetails details = ...;</span><br><span class="line">ErrorStatus status;</span><br><span class="line">status.<span class="built_in">add_details</span>()-&gt;<span class="built_in">PackFrom</span>(details);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reading an arbitrary message from Any.</span></span><br><span class="line">ErrorStatus status = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> Any&amp; detail : status.<span class="built_in">details</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (detail.<span class="built_in">Is</span>&lt;NetworkErrorDetails&gt;()) &#123;</span><br><span class="line">        NetworkErrorDetails network_error;</span><br><span class="line">        detail.<span class="built_in">UnpackTo</span>(&amp;network_error);</span><br><span class="line">        ... processing network_error ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前，用于Any类型的动态库仍在开发之中<br>如果你已经很熟悉<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/proto">proto2</a> 语法，使用Any替换<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/proto#extensions">拓展</a>.</p>
<h2 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h2><p>如果你的消息中有很多可选字段， 并且同时至多一个字段会被设置， 你可以加强这个行为，使用oneof特性节省内存.</p>
<p>Oneof字段就像可选字段， 除了它们会共享内存， 至多一个字段会被设置。 设置其中一个字段会清除其它字段。 你可以使用<code>case()</code>或者<code>WhichOneof() </code>方法检查哪个oneof字段被设置， 看你使用什么语言了.</p>
<h3 id="使用Oneof"><a href="#使用Oneof" class="headerlink" title="使用Oneof"></a>使用Oneof</h3><p>为了在<code>.proto</code>定义Oneof字段， 你需要在名字前面加上oneof关键字, 比如下面例子的test_oneof:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SampleMessage</span> &#123;</span><br><span class="line">    <span class="keyword">oneof</span> test_oneof &#123;</span><br><span class="line">        <span class="type">string</span> name = <span class="number">4</span>;</span><br><span class="line">        SubMessage sub_message = <span class="number">9</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以增加oneof字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用<code>repeated</code> 关键字.</p>
<p>在产生的代码中, oneof字段拥有同样的 getters 和setters， 就像正常的可选字段一样. 也有一个特殊的方法来检查到底那个字段被设置. 你可以在相应的语言API指南中找到oneof API介绍.</p>
<h3 id="Oneof-特性"><a href="#Oneof-特性" class="headerlink" title="Oneof 特性"></a>Oneof 特性</h3><ul>
<li>设置oneof会自动清楚其它oneof字段的值. 所以设置多次后，只有最后一次设置的字段有值.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">CHECK</span>(message.<span class="built_in">has_name</span>());</span><br><span class="line">message.<span class="built_in">mutable_sub_message</span>();   <span class="comment">// Will clear name field.</span></span><br><span class="line"><span class="built_in">CHECK</span>(!message.<span class="built_in">has_name</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>如果解析器遇到同一个oneof中有多个成员，只有最会一个会被解析成消息。</li>
<li>oneof不支持<code>repeated</code>.</li>
<li>反射API对oneof字段有效.</li>
<li>如果使用C++,需确保代码不会导致内存泄漏. 下面的代码会崩溃， 因为<code>sub_message</code>已经通过<code>set_name()</code>删除了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">SubMessage* sub_message = message.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);      <span class="comment">// Will delete sub_message</span></span><br><span class="line">sub_message-&gt;set_...            <span class="comment">// Crashes here</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在C++中，如果你使用<code>Swap()</code>两个oneof消息，每个消息，两个消息将拥有对方的值，例如在下面的例子中，<code>msg1</code>会拥有<code>sub_message</code>并且<code>msg2</code>会有name。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage msg1;</span><br><span class="line">msg1.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">SampleMessage msg2;</span><br><span class="line">msg2.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">msg1.<span class="built_in">swap</span>(&amp;msg2);</span><br><span class="line"><span class="built_in">CHECK</span>(msg1.<span class="built_in">has_sub_message</span>());</span><br><span class="line"><span class="built_in">CHECK</span>(msg2.<span class="built_in">has_name</span>());</span><br></pre></td></tr></table></figure>

<h3 id="向后兼容性问题"><a href="#向后兼容性问题" class="headerlink" title="向后兼容性问题"></a>向后兼容性问题</h3><p>当增加或者删除oneof字段时一定要小心. 如果检查oneof的值返回<code>None/NOT_SET</code>, 它意味着oneof字段没有被赋值或者在一个不同的版本中赋值了。 你不会知道是哪种情况，因为没有办法判断如果未识别的字段是一个oneof字段。</p>
<h2 id="Tage-重用问题："><a href="#Tage-重用问题：" class="headerlink" title="Tage 重用问题："></a>Tage 重用问题：</h2><ul>
<li><p><code>将字段移入或移除oneof</code>：在消息被序列号或者解析后，你也许会失去一些信息（有些字段也许会被清除）</p>
</li>
<li><p><code>删除一个字段或者加入一个字段</code>：在消息被序列号或者解析后，这也许会清除你现在设置的oneof字段</p>
</li>
<li><p><code>分离或者融合oneof</code>：行为与移动常规字段相似。</p>
</li>
</ul>
<h2 id="Map（映射）"><a href="#Map（映射）" class="headerlink" title="Map（映射）"></a>Map（映射）</h2><p>如果你希望创建一个关联映射，protocol buffer提供了一种快捷的语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure>

<p>其中<code>key_type</code>可以是任意Integer或者string类型（所以，除了floating和bytes的任意标量类型都是可以的）<code>value_type</code>可以是任意类型。</p>
<p>例如，如果你希望创建一个project的映射，每个<code>Projecct</code>使用一个string作为key，你可以像下面这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, Project&gt; projects = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Map的字段可以是<code>repeated</code>。</li>
<li>序列化后的顺序和map迭代器的顺序是不确定的，所以你不要期望以固定顺序处理Map</li>
<li>当为<code>.proto</code>文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。</li>
<li>从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key。</li>
<li>如果为映射字段提供键但没有值，则字段序列化时的行为取决于语言。 在C ++，Java和Python中，类型的默认值是序列化的，而在其他语言中不会序列化。</li>
</ul>
<p>生成map的API现在对于所有proto3支持的语言都可用了，你可以从<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/reference/overview">API指南</a> 找到更多信息。</p>
<h3 id="向后兼容性问题-1"><a href="#向后兼容性问题-1" class="headerlink" title="向后兼容性问题"></a>向后兼容性问题</h3><p>map语法序列化后等同于如下内容，因此即使是不支持map语法的protocol buffer实现也是可以处理你的数据的：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">MapFieldEntry</span> &#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeated</span> MapFieldEntry map_field = N;</span><br></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>当然可以为<code>.proto</code>文件新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Open</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>在其他的消息格式定义中可以使用包名+消息名的方式来定义域的类型，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    foo.bar.Open open = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包的声明符会根据使用语言的不同影响生成的代码。</p>
<ul>
<li><p>对于<code>C++</code>，产生的类会被包装在C++的命名空间中，如上例中的Open会被封装在 <code>foo::bar</code>空间中；</p>
</li>
<li><p>对于<code>Java</code>，包声明符会变为java的一个包，除非在<code>.proto</code>文件中提供了一个明确有java_package；</p>
</li>
<li><p>对于 <code>Python</code>，这个包声明符是被忽略的，因为Python模块是按照其在文件系统中的位置进行组织的。</p>
</li>
<li><p>对于<code>Go</code>，包可以被用做Go包名称，除非你显式的提供一个<code>option go_package</code>在你的<code>.proto</code>文件中。</p>
</li>
<li><p>对于<code>Ruby</code>，生成的类可以被包装在内置的Ruby名称空间中，转换成<code>Ruby</code>所需的大小写样式 （首字母大写；如果第一个符号不是一个字母，则使用PB_前缀），例如Open会在<code>Foo::Bar</code>名称空间中。</p>
<p>对于javaNano包会使用<code>Java</code>包，除非你在你的文件中显式的提供一个<code>option java_package</code>。</p>
</li>
<li><p>对于<code>C#</code>包可以转换为<code>PascalCase</code>后作为名称空间，除非你在你的文件中显式的提供一个<code>option csharp_namespace</code>，例如，Open会在<code>Foo.Bar</code>名称空间中</p>
</li>
</ul>
<h3 id="包及名称的解析"><a href="#包及名称的解析" class="headerlink" title="包及名称的解析"></a>包及名称的解析</h3><p>Protocol buffer语言中类型名称的解析与C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于 （<code>foo.bar.Baz</code>）这样以“.”分隔的意味着是从最外围开始的。</p>
<p>ProtocolBuffer编译器会解析<code>.proto</code>文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p>
<h2 id="定义服务-Service"><a href="#定义服务-Service" class="headerlink" title="定义服务(Service)"></a>定义服务(Service)</h2><p>如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span> &#123;</span><br><span class="line">  	<span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最直观的使用protocol buffer的RPC系统是<code>gRPC</code>一个由谷歌开发的语言和平台中的开源的PRC系统，<code>gRPC</code>在使用protocl buffer时非常有效，如果使用特殊的protocol buffer插件可以直接为您从.proto文件中产生相关的RPC代码。</p>
<p>如果你不想使用<code>gRPC</code>，也可以使用protocol buffer用于自己的RPC实现，你可以从proto2语言指南中找到更多信息</p>
<p>还有一些第三方开发的PRC实现使用Protocol Buffer。<a target="_blank" rel="noopener" href="https://github.com/google/protobuf/blob/master/docs/third_party.md">参考第三方插件wiki查看这些实现的列表</a>。</p>
<h2 id="JSON-映射"><a href="#JSON-映射" class="headerlink" title="JSON 映射"></a>JSON 映射</h2><p>Proto3 支持JSON的编码规范，使他更容易在不同系统之间共享数据，在下表中逐个描述类型。</p>
<p>如果JSON编码的数据丢失或者其本身就是null，这个数据会在解析成protocol buffer的时候被表示成默认值。如果一个字段在protocol buffer中表示为默认值，体会在转化成JSON的时候编码的时候忽略掉以节省空间。具体实现可以提供在JSON编码中可选的默认值。</p>
<table>
<thead>
<tr>
<th>proto3</th>
<th>JSON</th>
<th>JSON示例</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>message</td>
<td>object</td>
<td>{“fBar”: v, “g”: null, …}</td>
<td>产生JSON对象，消息字段名可以被映射成lowerCamelCase形式，并且成为JSON对象键，null被接受并成为对应字段的默认值</td>
</tr>
<tr>
<td>enum</td>
<td>string</td>
<td>“FOO_BAR”</td>
<td>枚举值的名字在proto文件中被指定</td>
</tr>
<tr>
<td>map</td>
<td>object</td>
<td>{“k”: v, …}</td>
<td>所有的键都被转换成string</td>
</tr>
<tr>
<td>repeated V</td>
<td>array</td>
<td>[v, …]</td>
<td>null被视为空列表</td>
</tr>
<tr>
<td>bool</td>
<td>true, false</td>
<td>true, false</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>“Hello World!”</td>
<td></td>
</tr>
<tr>
<td>bytes</td>
<td>base64 string</td>
<td>“YWJjMTIzIT8kKiYoKSctPUB+”</td>
<td></td>
</tr>
<tr>
<td>int32, fixed32, uint32</td>
<td>number</td>
<td>1, -10, 0</td>
<td>JSON值会是一个十进制数，数值型或者string类型都会接受</td>
</tr>
<tr>
<td>int64, fixed64, uint64</td>
<td>string</td>
<td>“1”, “-10”</td>
<td>JSON值会是一个十进制数，数值型或者string类型都会接受</td>
</tr>
<tr>
<td>float, double</td>
<td>number</td>
<td>1.1, -10.0, 0, “NaN”, “Infinity”</td>
<td>JSON值会是一个数字或者一个指定的字符串如”NaN”,”infinity”或者”-Infinity”，数值型或者字符串都是可接受的，指数符号也可以接受</td>
</tr>
<tr>
<td>Any</td>
<td>object</td>
<td>{“@type”: “url”, “f”: v, … }</td>
<td>如果一个Any保留一个特上述的JSON映射，则它会转换成一个如下形式：<code>&#123;&quot;@type&quot;: xxx, &quot;value&quot;: yyy&#125;</code>否则，该值会被转换成一个JSON对象，<code>@type</code>字段会被插入所指定的确定的值</td>
</tr>
<tr>
<td>Timestamp</td>
<td>string</td>
<td>“1972-01-01T10:00:20.021Z”</td>
<td>使用RFC 339，其中生成的输出将始终是Z-归一化啊的，并且使用0，3，6或者9位小数</td>
</tr>
<tr>
<td>Duration</td>
<td>string</td>
<td>“1.000340012s”, “1s”</td>
<td>生成的输出总是0，3，6或者9位小数，具体依赖于所需要的精度，接受所有可以转换为纳秒级的精度</td>
</tr>
<tr>
<td>Struct</td>
<td>object</td>
<td>{ … }</td>
<td>任意的JSON对象，见struct.proto</td>
</tr>
<tr>
<td>Wrapper types</td>
<td>various types</td>
<td>2, “2”, “foo”, true, “true”, null, 0, …</td>
<td>包装器在JSON中的表示方式类似于基本类型，但是允许nulll，并且在转换的过程中保留null</td>
</tr>
<tr>
<td>FieldMask</td>
<td>string</td>
<td>“f.fooBar,h”</td>
<td>见fieldmask.proto</td>
</tr>
<tr>
<td>ListValue</td>
<td>array</td>
<td>[foo, bar, …]</td>
<td></td>
</tr>
<tr>
<td>Value</td>
<td>value</td>
<td></td>
<td>任意JSON值</td>
</tr>
<tr>
<td>NullValue</td>
<td>null</td>
<td></td>
<td>JSON null</td>
</tr>
</tbody></table>
<h3 id="JSON选项"><a href="#JSON选项" class="headerlink" title="JSON选项"></a>JSON选项</h3><p>proto3 JSON实现可以提供以下选项：      </p>
<ul>
<li>使用默认值发出字段：默认情况下，proto3 JSON输出中省略了具有默认值的字段。实现可以提供覆盖此行为的选项，并使用其默认值输出字段。     </li>
<li>忽略未知字段：默认情况下，Proto3 JSON解析器应拒绝未知字段，但可以提供忽略解析中未知字段的选项。</li>
<li>使用proto字段名称而不是lowerCamelCase名称：默认情况下，proto3 JSON打印机应将字段名称转换为lowerCamelCase并将其用作JSON名称。实现可以提供使用proto字段名称作为JSON名称的选项。 Proto3 JSON解析器需要接受转换后的lowerCamelCase名称和proto字段名称。     </li>
<li>将枚举值发送为整数而不是字符串：默认情况下，在JSON输出中使用枚举值的名称。可以提供选项以使用枚举值的数值。</li>
</ul>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>在定义<code>.proto</code>文件时能够标注一系列的options。Options并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。完整的可用选项可以在&#96;&#96;google&#x2F;protobuf&#x2F;descriptor.proto&#96;找到。</p>
<p>一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum或服务定义中。一些选项是消息级别的，意味着它可以用在消息定义的内部。当然有些选项可以作用在域、enum类型、enum值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。</p>
<p>如下就是一些常用的选择：</p>
<ul>
<li><code>java_package</code> (文件选项) :这个选项表明生成java类所在的包。如果在<code>.proto</code>文件中没有明确的声明<code>java_package</code>，就采用默认的包名。当然了，默认方式产生的<code>java</code>包名并不是最好的方式，按照应用名称倒序方式进行排序的。如果不需要产生<code>java</code>代码，则该选项将不起任何作用。如：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.example.foo&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>java_multiple_files</code>（文件选项）：导致在包级别定义顶级消息，枚举和服务，而不是在<code>.proto</code>文件之后命名的外部类中。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>java_outer_classname</code> (文件选项): 该选项表明想要生成Java类的名称。如果在<code>.proto</code>文件中没有明确的<code>java_outer_classname</code>定义，生成的class名称将会根据<code>.proto</code>文件的名称采用驼峰式的命名方式进行生成。如（<code>foo_bar.proto</code>生成的java类名为<code>FooBar.java</code>）,如果不生成java代码，则该选项不起任何作用。如：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;Ponycopter&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>optimize_for</code>(文件选项): 可以被设置为 <code>SPEED, CODE_SIZE,或者LITE_RUNTIME</code>。这些值将通过如下的方式影响C++及java代码的生成：<ul>
<li><code>SPEED </code>(default): protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</li>
<li><code>CODE_SIZE</code>: protocol buffer编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比SPEED要少得多， 但是操作要相对慢些。当然实现的类及其对外的API与SPEED模式都是一样的。这种方式经常用在一些包含大量的.proto文件而且并不盲目追求速度的 应用中。</li>
<li><code>LITE_RUNTIME</code>: protocol buffer编译器依赖于运行时核心类库来生成代码（即采用libprotobuf-lite 替代libprotobuf）。这种核心类库由于忽略了一 些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</li>
</ul>
</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> optimize_for = CODE_SIZE;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cc_enable_arenas</code>(文件选项):对于C++产生的代码启用<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/reference/arenas">arena allocation</a></li>
<li><code>objc_class_prefix</code>(文件选项):设置Objective-C类的前缀，添加到所有Objective-C从此.proto文件产生的类和枚举类型。没有默认值，所使用的前缀应该是苹果推荐的3-5个大写字符，注意2个字节的前缀是苹果所保留的。</li>
<li><code>deprecated</code>(字段选项):如果设置为true则表示该字段已经被废弃，并且不应该在新的代码中使用。在大多数语言中没有实际的意义。在java中，这回变成<code>@Deprecated</code>注释，在未来，其他语言的代码生成器也许会在字标识符中产生废弃注释，废弃注释会在编译器尝试使用该字段时发出警告。如果字段没有被使用你也不希望有新用户使用它，尝试使用保留语句替换字段声明。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32</span> old_field = <span class="number">6</span> [deprecated=<span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<h3 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h3><p>ProtocolBuffers允许自定义并使用选项。该功能应该属于一个高级特性，对于大部分人是用不到的。如果你的确希望创建自己的选项，请参看 <a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/proto.html#customoptions">Proto2 Language Guide</a>。注意创建自定义选项使用了拓展，拓展只在proto3中可用。</p>
<h2 id="生成访问类"><a href="#生成访问类" class="headerlink" title="生成访问类"></a>生成访问类</h2><p>可以通过定义好的<code>.proto</code>文件来生成<code>Java,Python,C++, Ruby, JavaNano, Objective-C</code>,或者C# 代码，需要基于<code>.proto</code>文件运行protocol buffer编译器protoc。如果你没有安装编译器，下载安装包并遵照README安装。对于Go,你还需要安装一个特殊的代码生成器插件。你可以通过GitHub上的protobuf库找到安装过程</p>
<p>通过如下方式调用protocol编译器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>IMPORT_PATH</code>声明了一个<code>.proto</code>文件所在的解析import具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以多次调用<code>--proto_path</code>，它们将会顺序的被访问并执行导入。&#96;&#96;-I&#x3D;IMPORT_PATH<code>是</code>--proto_path&#96;的简化形式。</p>
</li>
<li><p>当然也可以提供一个或多个输出路径：</p>
<ul>
<li><code>--cpp_out</code> 在目标目录DST_DIR中产生C++代码，可以在C++代码生成参考中查看更多。</li>
<li><code>--java_out</code> 在目标目录DST_DIR中产生Java代码，可以在 Java代码生成参考中查看更多。</li>
<li><code>--python_out</code> 在目标目录 DST_DIR 中产生Python代码，可以在Python代码生成参考中查看更多。</li>
<li><code>--go_out</code> 在目标目录 DST_DIR 中产生Go代码，可以在GO代码生成参考中查看更多。</li>
<li><code>--ruby_out</code>在目标目录 DST_DIR 中产生Go代码，参考正在制作中。</li>
<li><code>--objc_out</code>在目标目录DST_DIR中产生Object代码，可以在Objective-C代码生成参考中查看更多。</li>
<li><code>--csharp_out</code>在目标目录DST_DIR中产生Object代码，可以在C#代码生成参考中查看更多。</li>
<li><code>--php_out</code>在目标目录DST_DIR中产生Object代码，可以在PHP代码生成参考中查看更多。</li>
</ul>
<p>作为一个方便的拓展，如果DST_DIR以.zip或者.jar结尾，编译器会将输出写到一个ZIP格式文件或者符合JAR标准的.jar文件中。注意如果输出已经存在则会被覆盖，编译器还没有智能到可以追加文件。</p>
</li>
<li><p>你必须提议一个或多个<code>.proto</code>文件作为输入，多个<code>.proto</code>文件可以只指定一次。虽然文件路径是相对于当前目录的，每个文件必须位于其<code>IMPORT_PATH</code>下，以便每个文件可以确定其规范的名称。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wangyyovo.github.io">Blank</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wangyyovo.github.io/posts/2658c59b/">https://wangyyovo.github.io/posts/2658c59b/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wangyyovo.github.io" target="_blank">Blank</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/protobuf/f0c430a4a8138df369038db54a3b8af2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://jsd.012700.xyz/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://jsd.012700.xyz/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/340f01c0/" title="Golang中使用protobuf高效编码"><img class="cover" src="https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/protobuf/090cfe4e9e60b0ad0de05db822f3ae97.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang中使用protobuf高效编码</div></div><div class="info-2"><div class="info-item-1"> Golang中使用protobuf高效编码Protocol Buffers 是Google推出的一种数据交换格式。二进制、高性能、跨平台、跨编程语言。很适合现在分布式、微服务中结合消息总线做高性能数据交换。 定义 *.proto1234567891011121314151617181920212223242526syntax = &quot;proto3&quot;;package tutorial;message Person &#123;  string name = 1;  int32 id = 2;  // Unique ID number for this person.  string email = 3;  enum PhoneType &#123;    MOBILE = 0;    HOME = 1;    WORK = 2;  &#125;  message PhoneNumber &#123;    string number = 1;    PhoneType type = 2;  &#125;  repeated PhoneNumber phones ...</div></div></div></a><a class="pagination-related" href="/posts/b8d70186/" title="proto3与proto2的区别"><img class="cover" src="https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/protobuf/e6c93b865b210a58311ecb7961e87e89.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">proto3与proto2的区别</div></div><div class="info-2"><div class="info-item-1"> 这是一篇学习笔记。在粗略的看了 Protobuf 的文档中关于 proto2 和 proto3 的说明后，记录下了几点 proto3 区别于 proto2 的地方。 总的来说，proto3 比 proto2 支持更多语言但 更简洁。去掉了一些复杂的语法和特性，更强调约定而弱化语法。如果是首次使用 Protobuf ，建议使用 proto3 。  在第一行非空白非注释行，必须写： syntax &#x3D; &quot;proto3&quot;;  字段规则移除了 “required”，并把 “optional” 改名为 “singular”1； 在 proto2 中 required 也是不推荐使用的。proto3 直接从语法层面上移除了 required 规则。其实可以做的更彻底，把所有字段规则描述都撤销，原来的 repeated 改为在类型或字段名后加一对中括号。这样是不是更简洁？  “repeated”字段默认采用 packed 编码； 在 proto2 中，需要明确使用 [packed=true] 来为字段指定比较紧凑的 packed 编码方式。  语言增加 Go、Ru...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/wangyyovo/CDN@master/theme/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Blank</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">352</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>主题 GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Protobuf-%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97-proto-3"><span class="toc-number">1.</span> <span class="toc-text">Protobuf 语言指南(proto 3)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">定义一个消息类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">指定字段类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%A0%87%E8%AF%86%E5%8F%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">分配标识号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E8%A7%84%E5%88%99"><span class="toc-number">1.1.3.</span> <span class="toc-text">指定字段规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">添加更多消息类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.5.</span> <span class="toc-text">添加注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-proto%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.6.</span> <span class="toc-text">从.proto文件生成了什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">标量数值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.3.</span> <span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.4.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88Reserved%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">保留标识符（Reserved）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">使用其他消息类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">导入定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8proto2%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">使用proto2消息类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">更新一个消息类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Any"><span class="toc-number">1.7.</span> <span class="toc-text">Any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Oneof"><span class="toc-number">1.8.</span> <span class="toc-text">Oneof</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Oneof"><span class="toc-number">1.8.1.</span> <span class="toc-text">使用Oneof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oneof-%E7%89%B9%E6%80%A7"><span class="toc-number">1.8.2.</span> <span class="toc-text">Oneof 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.3.</span> <span class="toc-text">向后兼容性问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tage-%E9%87%8D%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">Tage 重用问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">Map（映射）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98-1"><span class="toc-number">1.10.1.</span> <span class="toc-text">向后兼容性问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.11.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%8F%8A%E5%90%8D%E7%A7%B0%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.11.1.</span> <span class="toc-text">包及名称的解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1-Service"><span class="toc-number">1.12.</span> <span class="toc-text">定义服务(Service)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON-%E6%98%A0%E5%B0%84"><span class="toc-number">1.13.</span> <span class="toc-text">JSON 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON%E9%80%89%E9%A1%B9"><span class="toc-number">1.13.1.</span> <span class="toc-text">JSON选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E9%A1%B9"><span class="toc-number">1.14.</span> <span class="toc-text">选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%89%E9%A1%B9"><span class="toc-number">1.14.1.</span> <span class="toc-text">自定义选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%AE%BF%E9%97%AE%E7%B1%BB"><span class="toc-number">1.15.</span> <span class="toc-text">生成访问类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d14168d/" title="虚拟机问题合集"><img src="https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/hexo/090cfe4e9e60b0ad0de05db822f3ae97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="虚拟机问题合集"/></a><div class="content"><a class="title" href="/posts/d14168d/" title="虚拟机问题合集">虚拟机问题合集</a><time datetime="2022-07-16T13:30:36.000Z" title="发表于 2022-07-16 21:30:36">2022-07-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f540045f/" title="用go语言编写移动端sdk和app开发"><img src="https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/golang/941ed1ec2925719a0c92e76f4f786b6a.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用go语言编写移动端sdk和app开发"/></a><div class="content"><a class="title" href="/posts/f540045f/" title="用go语言编写移动端sdk和app开发">用go语言编写移动端sdk和app开发</a><time datetime="2022-07-04T12:14:21.000Z" title="发表于 2022-07-04 20:14:21">2022-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5faac006/" title="在线编程IDE"><img src="https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/hexo/090cfe4e9e60b0ad0de05db822f3ae97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在线编程IDE"/></a><div class="content"><a class="title" href="/posts/5faac006/" title="在线编程IDE">在线编程IDE</a><time datetime="2022-06-12T13:30:36.000Z" title="发表于 2022-06-12 21:30:36">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7594185d/" title="即时性能分析工具Pyroscope"><img src="https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/golang/3bfb3279740bc9a5b5ef436fa887ef07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="即时性能分析工具Pyroscope"/></a><div class="content"><a class="title" href="/posts/7594185d/" title="即时性能分析工具Pyroscope">即时性能分析工具Pyroscope</a><time datetime="2022-06-12T08:07:36.000Z" title="发表于 2022-06-12 16:07:36">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/82a7aa7c/" title="golang性能调试优化方法"><img src="https://jsd.012700.xyz/gh/wangyyovo/CDN@master/cover/common/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="golang性能调试优化方法"/></a><div class="content"><a class="title" href="/posts/82a7aa7c/" title="golang性能调试优化方法">golang性能调试优化方法</a><time datetime="2022-06-12T03:00:36.000Z" title="发表于 2022-06-12 11:00:36">2022-06-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Blank</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 5.4.2</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://jsd.012700.xyz/npm/hexo-theme-butterfly/source/js/utils.min.js"></script><script src="https://jsd.012700.xyz/npm/hexo-theme-butterfly/source/js/main.min.js"></script><script src="https://jsd.012700.xyz/npm/hexo-theme-butterfly/source/js/tw_cn.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"placeholder":"请留下你的脚印","pageSize":10,"lang":"zh-CN","requiredFields":["nick","mail","link"]}

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'BSfgwCPLOvPHVPaSoBCGSENf-MdYXbMMI',
      appKey: '2Q8qq5060qxycL6FPL26LnMG',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://jsd.012700.xyz/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://jsd.012700.xyz/npm/hexo-theme-butterfly/source/js/search/local-search.min.js"></script></div></div></body></html>